schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

"""whether this query should be cached (Hasura Cloud only)"""
directive @cached(
  """measured in seconds"""
  ttl: Int! = 60

  """refresh the cache entry"""
  refresh: Boolean! = false
) on QUERY

"""
Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'.
"""
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

"""
Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'.
"""
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

"""
Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'.
"""
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String

  """does the column match the given case-insensitive pattern"""
  _ilike: String
  _in: [String!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: String
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: String
  _lt: String
  _lte: String
  _neq: String

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: String
  _nin: [String!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: String

  """does the column NOT match the given pattern"""
  _nlike: String

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: String

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: String

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: String

  """does the column match the given SQL regular expression"""
  _similar: String
}

"""
columns and relationships of "app_user"
"""
type app_user {
  """An array relationship"""
  chatroom_messages(
    """distinct select on columns"""
    distinct_on: [chatroom_message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_message_order_by!]

    """filter the rows returned"""
    where: chatroom_message_bool_exp
  ): [chatroom_message!]!

  """An aggregate relationship"""
  chatroom_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [chatroom_message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_message_order_by!]

    """filter the rows returned"""
    where: chatroom_message_bool_exp
  ): chatroom_message_aggregate!

  """An array relationship"""
  chatrooms(
    """distinct select on columns"""
    distinct_on: [chatroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_order_by!]

    """filter the rows returned"""
    where: chatroom_bool_exp
  ): [chatroom!]!

  """An array relationship"""
  chatroomsByCreateuserid(
    """distinct select on columns"""
    distinct_on: [chatroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_order_by!]

    """filter the rows returned"""
    where: chatroom_bool_exp
  ): [chatroom!]!

  """An aggregate relationship"""
  chatroomsByCreateuserid_aggregate(
    """distinct select on columns"""
    distinct_on: [chatroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_order_by!]

    """filter the rows returned"""
    where: chatroom_bool_exp
  ): chatroom_aggregate!

  """An aggregate relationship"""
  chatrooms_aggregate(
    """distinct select on columns"""
    distinct_on: [chatroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_order_by!]

    """filter the rows returned"""
    where: chatroom_bool_exp
  ): chatroom_aggregate!

  """An array relationship"""
  clothingStatusesByOwnerid(
    """distinct select on columns"""
    distinct_on: [clothing_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_status_order_by!]

    """filter the rows returned"""
    where: clothing_status_bool_exp
  ): [clothing_status!]!

  """An aggregate relationship"""
  clothingStatusesByOwnerid_aggregate(
    """distinct select on columns"""
    distinct_on: [clothing_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_status_order_by!]

    """filter the rows returned"""
    where: clothing_status_bool_exp
  ): clothing_status_aggregate!

  """An array relationship"""
  clothing_statuses(
    """distinct select on columns"""
    distinct_on: [clothing_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_status_order_by!]

    """filter the rows returned"""
    where: clothing_status_bool_exp
  ): [clothing_status!]!

  """An aggregate relationship"""
  clothing_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [clothing_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_status_order_by!]

    """filter the rows returned"""
    where: clothing_status_bool_exp
  ): clothing_status_aggregate!

  """An array relationship"""
  clothings(
    """distinct select on columns"""
    distinct_on: [clothing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_order_by!]

    """filter the rows returned"""
    where: clothing_bool_exp
  ): [clothing!]!

  """An aggregate relationship"""
  clothings_aggregate(
    """distinct select on columns"""
    distinct_on: [clothing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_order_by!]

    """filter the rows returned"""
    where: clothing_bool_exp
  ): clothing_aggregate!
  createdAt: timestamp
  gender: String

  """An array relationship"""
  group_members(
    """distinct select on columns"""
    distinct_on: [group_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_member_order_by!]

    """filter the rows returned"""
    where: group_member_bool_exp
  ): [group_member!]!

  """An aggregate relationship"""
  group_members_aggregate(
    """distinct select on columns"""
    distinct_on: [group_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_member_order_by!]

    """filter the rows returned"""
    where: group_member_bool_exp
  ): group_member_aggregate!

  """An array relationship"""
  groups(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): [group!]!

  """An aggregate relationship"""
  groups_aggregate(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): group_aggregate!
  id: String!
  lastOnline: timestamp
  loginProvider: String
  name: String
  spaceLocation: String

  """An array relationship"""
  userFollowingsByUserid(
    """distinct select on columns"""
    distinct_on: [user_following_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_following_order_by!]

    """filter the rows returned"""
    where: user_following_bool_exp
  ): [user_following!]!

  """An aggregate relationship"""
  userFollowingsByUserid_aggregate(
    """distinct select on columns"""
    distinct_on: [user_following_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_following_order_by!]

    """filter the rows returned"""
    where: user_following_bool_exp
  ): user_following_aggregate!

  """An array relationship"""
  user_avatars(
    """distinct select on columns"""
    distinct_on: [user_avatar_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_avatar_order_by!]

    """filter the rows returned"""
    where: user_avatar_bool_exp
  ): [user_avatar!]!

  """An aggregate relationship"""
  user_avatars_aggregate(
    """distinct select on columns"""
    distinct_on: [user_avatar_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_avatar_order_by!]

    """filter the rows returned"""
    where: user_avatar_bool_exp
  ): user_avatar_aggregate!

  """An array relationship"""
  user_followings(
    """distinct select on columns"""
    distinct_on: [user_following_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_following_order_by!]

    """filter the rows returned"""
    where: user_following_bool_exp
  ): [user_following!]!

  """An aggregate relationship"""
  user_followings_aggregate(
    """distinct select on columns"""
    distinct_on: [user_following_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_following_order_by!]

    """filter the rows returned"""
    where: user_following_bool_exp
  ): user_following_aggregate!

  """An array relationship"""
  user_wardrobes(
    """distinct select on columns"""
    distinct_on: [user_wardrobe_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wardrobe_order_by!]

    """filter the rows returned"""
    where: user_wardrobe_bool_exp
  ): [user_wardrobe!]!

  """An aggregate relationship"""
  user_wardrobes_aggregate(
    """distinct select on columns"""
    distinct_on: [user_wardrobe_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wardrobe_order_by!]

    """filter the rows returned"""
    where: user_wardrobe_bool_exp
  ): user_wardrobe_aggregate!

  """An array relationship"""
  user_wishlists(
    """distinct select on columns"""
    distinct_on: [user_wishlist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wishlist_order_by!]

    """filter the rows returned"""
    where: user_wishlist_bool_exp
  ): [user_wishlist!]!

  """An aggregate relationship"""
  user_wishlists_aggregate(
    """distinct select on columns"""
    distinct_on: [user_wishlist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wishlist_order_by!]

    """filter the rows returned"""
    where: user_wishlist_bool_exp
  ): user_wishlist_aggregate!
}

"""
aggregated selection of "app_user"
"""
type app_user_aggregate {
  aggregate: app_user_aggregate_fields
  nodes: [app_user!]!
}

"""
aggregate fields of "app_user"
"""
type app_user_aggregate_fields {
  count(columns: [app_user_select_column!], distinct: Boolean): Int!
  max: app_user_max_fields
  min: app_user_min_fields
}

"""
Boolean expression to filter rows from the table "app_user". All fields are combined with a logical 'AND'.
"""
input app_user_bool_exp {
  _and: [app_user_bool_exp!]
  _not: app_user_bool_exp
  _or: [app_user_bool_exp!]
  chatroom_messages: chatroom_message_bool_exp
  chatrooms: chatroom_bool_exp
  chatroomsByCreateuserid: chatroom_bool_exp
  clothingStatusesByOwnerid: clothing_status_bool_exp
  clothing_statuses: clothing_status_bool_exp
  clothings: clothing_bool_exp
  createdAt: timestamp_comparison_exp
  gender: String_comparison_exp
  group_members: group_member_bool_exp
  groups: group_bool_exp
  id: String_comparison_exp
  lastOnline: timestamp_comparison_exp
  loginProvider: String_comparison_exp
  name: String_comparison_exp
  spaceLocation: String_comparison_exp
  userFollowingsByUserid: user_following_bool_exp
  user_avatars: user_avatar_bool_exp
  user_followings: user_following_bool_exp
  user_wardrobes: user_wardrobe_bool_exp
  user_wishlists: user_wishlist_bool_exp
}

"""
unique or primary key constraints on table "app_user"
"""
enum app_user_constraint {
  """unique or primary key constraint"""
  app_user_pkey
}

"""
input type for inserting data into table "app_user"
"""
input app_user_insert_input {
  chatroom_messages: chatroom_message_arr_rel_insert_input
  chatrooms: chatroom_arr_rel_insert_input
  chatroomsByCreateuserid: chatroom_arr_rel_insert_input
  clothingStatusesByOwnerid: clothing_status_arr_rel_insert_input
  clothing_statuses: clothing_status_arr_rel_insert_input
  clothings: clothing_arr_rel_insert_input
  createdAt: timestamp
  gender: String
  group_members: group_member_arr_rel_insert_input
  groups: group_arr_rel_insert_input
  id: String
  lastOnline: timestamp
  loginProvider: String
  name: String
  spaceLocation: String
  userFollowingsByUserid: user_following_arr_rel_insert_input
  user_avatars: user_avatar_arr_rel_insert_input
  user_followings: user_following_arr_rel_insert_input
  user_wardrobes: user_wardrobe_arr_rel_insert_input
  user_wishlists: user_wishlist_arr_rel_insert_input
}

"""aggregate max on columns"""
type app_user_max_fields {
  createdAt: timestamp
  gender: String
  id: String
  lastOnline: timestamp
  loginProvider: String
  name: String
  spaceLocation: String
}

"""aggregate min on columns"""
type app_user_min_fields {
  createdAt: timestamp
  gender: String
  id: String
  lastOnline: timestamp
  loginProvider: String
  name: String
  spaceLocation: String
}

"""
response of any mutation on the table "app_user"
"""
type app_user_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [app_user!]!
}

"""
input type for inserting object relation for remote table "app_user"
"""
input app_user_obj_rel_insert_input {
  data: app_user_insert_input!

  """upsert condition"""
  on_conflict: app_user_on_conflict
}

"""
on_conflict condition type for table "app_user"
"""
input app_user_on_conflict {
  constraint: app_user_constraint!
  update_columns: [app_user_update_column!]! = []
  where: app_user_bool_exp
}

"""Ordering options when selecting data from "app_user"."""
input app_user_order_by {
  chatroom_messages_aggregate: chatroom_message_aggregate_order_by
  chatroomsByCreateuserid_aggregate: chatroom_aggregate_order_by
  chatrooms_aggregate: chatroom_aggregate_order_by
  clothingStatusesByOwnerid_aggregate: clothing_status_aggregate_order_by
  clothing_statuses_aggregate: clothing_status_aggregate_order_by
  clothings_aggregate: clothing_aggregate_order_by
  createdAt: order_by
  gender: order_by
  group_members_aggregate: group_member_aggregate_order_by
  groups_aggregate: group_aggregate_order_by
  id: order_by
  lastOnline: order_by
  loginProvider: order_by
  name: order_by
  spaceLocation: order_by
  userFollowingsByUserid_aggregate: user_following_aggregate_order_by
  user_avatars_aggregate: user_avatar_aggregate_order_by
  user_followings_aggregate: user_following_aggregate_order_by
  user_wardrobes_aggregate: user_wardrobe_aggregate_order_by
  user_wishlists_aggregate: user_wishlist_aggregate_order_by
}

"""primary key columns input for table: app_user"""
input app_user_pk_columns_input {
  id: String!
}

"""
select columns of table "app_user"
"""
enum app_user_select_column {
  """column name"""
  createdAt

  """column name"""
  gender

  """column name"""
  id

  """column name"""
  lastOnline

  """column name"""
  loginProvider

  """column name"""
  name

  """column name"""
  spaceLocation
}

"""
input type for updating data in table "app_user"
"""
input app_user_set_input {
  createdAt: timestamp
  gender: String
  id: String
  lastOnline: timestamp
  loginProvider: String
  name: String
  spaceLocation: String
}

"""
update columns of table "app_user"
"""
enum app_user_update_column {
  """column name"""
  createdAt

  """column name"""
  gender

  """column name"""
  id

  """column name"""
  lastOnline

  """column name"""
  loginProvider

  """column name"""
  name

  """column name"""
  spaceLocation
}

"""
columns and relationships of "auth.provider_requests"
"""
type authProviderRequests {
  id: uuid!
  redirectUrl: String!
}

"""
aggregated selection of "auth.provider_requests"
"""
type authProviderRequests_aggregate {
  aggregate: authProviderRequests_aggregate_fields
  nodes: [authProviderRequests!]!
}

"""
aggregate fields of "auth.provider_requests"
"""
type authProviderRequests_aggregate_fields {
  count(columns: [authProviderRequests_select_column!], distinct: Boolean): Int!
  max: authProviderRequests_max_fields
  min: authProviderRequests_min_fields
}

"""
Boolean expression to filter rows from the table "auth.provider_requests". All fields are combined with a logical 'AND'.
"""
input authProviderRequests_bool_exp {
  _and: [authProviderRequests_bool_exp!]
  _not: authProviderRequests_bool_exp
  _or: [authProviderRequests_bool_exp!]
  id: uuid_comparison_exp
  redirectUrl: String_comparison_exp
}

"""
unique or primary key constraints on table "auth.provider_requests"
"""
enum authProviderRequests_constraint {
  """unique or primary key constraint"""
  provider_requests_pkey
}

"""
input type for inserting data into table "auth.provider_requests"
"""
input authProviderRequests_insert_input {
  id: uuid
  redirectUrl: String
}

"""aggregate max on columns"""
type authProviderRequests_max_fields {
  id: uuid
  redirectUrl: String
}

"""aggregate min on columns"""
type authProviderRequests_min_fields {
  id: uuid
  redirectUrl: String
}

"""
response of any mutation on the table "auth.provider_requests"
"""
type authProviderRequests_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviderRequests!]!
}

"""
on_conflict condition type for table "auth.provider_requests"
"""
input authProviderRequests_on_conflict {
  constraint: authProviderRequests_constraint!
  update_columns: [authProviderRequests_update_column!]! = []
  where: authProviderRequests_bool_exp
}

"""Ordering options when selecting data from "auth.provider_requests"."""
input authProviderRequests_order_by {
  id: order_by
  redirectUrl: order_by
}

"""primary key columns input for table: authProviderRequests"""
input authProviderRequests_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.provider_requests"
"""
enum authProviderRequests_select_column {
  """column name"""
  id

  """column name"""
  redirectUrl
}

"""
input type for updating data in table "auth.provider_requests"
"""
input authProviderRequests_set_input {
  id: uuid
  redirectUrl: String
}

"""
update columns of table "auth.provider_requests"
"""
enum authProviderRequests_update_column {
  """column name"""
  id

  """column name"""
  redirectUrl
}

"""
columns and relationships of "auth.providers"
"""
type authProviders {
  id: String!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.providers"
"""
type authProviders_aggregate {
  aggregate: authProviders_aggregate_fields
  nodes: [authProviders!]!
}

"""
aggregate fields of "auth.providers"
"""
type authProviders_aggregate_fields {
  count(columns: [authProviders_select_column!], distinct: Boolean): Int!
  max: authProviders_max_fields
  min: authProviders_min_fields
}

"""
Boolean expression to filter rows from the table "auth.providers". All fields are combined with a logical 'AND'.
"""
input authProviders_bool_exp {
  _and: [authProviders_bool_exp!]
  _not: authProviders_bool_exp
  _or: [authProviders_bool_exp!]
  id: String_comparison_exp
  userProviders: authUserProviders_bool_exp
}

"""
unique or primary key constraints on table "auth.providers"
"""
enum authProviders_constraint {
  """unique or primary key constraint"""
  providers_pkey
}

"""
input type for inserting data into table "auth.providers"
"""
input authProviders_insert_input {
  id: String
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type authProviders_max_fields {
  id: String
}

"""aggregate min on columns"""
type authProviders_min_fields {
  id: String
}

"""
response of any mutation on the table "auth.providers"
"""
type authProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authProviders!]!
}

"""
input type for inserting object relation for remote table "auth.providers"
"""
input authProviders_obj_rel_insert_input {
  data: authProviders_insert_input!

  """upsert condition"""
  on_conflict: authProviders_on_conflict
}

"""
on_conflict condition type for table "auth.providers"
"""
input authProviders_on_conflict {
  constraint: authProviders_constraint!
  update_columns: [authProviders_update_column!]! = []
  where: authProviders_bool_exp
}

"""Ordering options when selecting data from "auth.providers"."""
input authProviders_order_by {
  id: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: authProviders"""
input authProviders_pk_columns_input {
  id: String!
}

"""
select columns of table "auth.providers"
"""
enum authProviders_select_column {
  """column name"""
  id
}

"""
input type for updating data in table "auth.providers"
"""
input authProviders_set_input {
  id: String
}

"""
update columns of table "auth.providers"
"""
enum authProviders_update_column {
  """column name"""
  id
}

"""
columns and relationships of "auth.refresh_tokens"
"""
type authRefreshTokens {
  createdAt: timestamptz!
  expiresAt: timestamptz!
  refreshToken: uuid!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate {
  aggregate: authRefreshTokens_aggregate_fields
  nodes: [authRefreshTokens!]!
}

"""
aggregate fields of "auth.refresh_tokens"
"""
type authRefreshTokens_aggregate_fields {
  count(columns: [authRefreshTokens_select_column!], distinct: Boolean): Int!
  max: authRefreshTokens_max_fields
  min: authRefreshTokens_min_fields
}

"""
order by aggregate values of table "auth.refresh_tokens"
"""
input authRefreshTokens_aggregate_order_by {
  count: order_by
  max: authRefreshTokens_max_order_by
  min: authRefreshTokens_min_order_by
}

"""
input type for inserting array relation for remote table "auth.refresh_tokens"
"""
input authRefreshTokens_arr_rel_insert_input {
  data: [authRefreshTokens_insert_input!]!

  """upsert condition"""
  on_conflict: authRefreshTokens_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.refresh_tokens". All fields are combined with a logical 'AND'.
"""
input authRefreshTokens_bool_exp {
  _and: [authRefreshTokens_bool_exp!]
  _not: authRefreshTokens_bool_exp
  _or: [authRefreshTokens_bool_exp!]
  createdAt: timestamptz_comparison_exp
  expiresAt: timestamptz_comparison_exp
  refreshToken: uuid_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.refresh_tokens"
"""
enum authRefreshTokens_constraint {
  """unique or primary key constraint"""
  refresh_tokens_pkey
}

"""
input type for inserting data into table "auth.refresh_tokens"
"""
input authRefreshTokens_insert_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authRefreshTokens_max_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  userId: uuid
}

"""
order by max() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_max_order_by {
  createdAt: order_by
  expiresAt: order_by
  refreshToken: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authRefreshTokens_min_fields {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  userId: uuid
}

"""
order by min() on columns of table "auth.refresh_tokens"
"""
input authRefreshTokens_min_order_by {
  createdAt: order_by
  expiresAt: order_by
  refreshToken: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.refresh_tokens"
"""
type authRefreshTokens_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRefreshTokens!]!
}

"""
on_conflict condition type for table "auth.refresh_tokens"
"""
input authRefreshTokens_on_conflict {
  constraint: authRefreshTokens_constraint!
  update_columns: [authRefreshTokens_update_column!]! = []
  where: authRefreshTokens_bool_exp
}

"""Ordering options when selecting data from "auth.refresh_tokens"."""
input authRefreshTokens_order_by {
  createdAt: order_by
  expiresAt: order_by
  refreshToken: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: authRefreshTokens"""
input authRefreshTokens_pk_columns_input {
  refreshToken: uuid!
}

"""
select columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_select_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  refreshToken

  """column name"""
  userId
}

"""
input type for updating data in table "auth.refresh_tokens"
"""
input authRefreshTokens_set_input {
  createdAt: timestamptz
  expiresAt: timestamptz
  refreshToken: uuid
  userId: uuid
}

"""
update columns of table "auth.refresh_tokens"
"""
enum authRefreshTokens_update_column {
  """column name"""
  createdAt

  """column name"""
  expiresAt

  """column name"""
  refreshToken

  """column name"""
  userId
}

"""
columns and relationships of "auth.roles"
"""
type authRoles {
  role: String!

  """An array relationship"""
  userRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  userRoles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """An array relationship"""
  usersByDefaultRole(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!

  """An aggregate relationship"""
  usersByDefaultRole_aggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!
}

"""
aggregated selection of "auth.roles"
"""
type authRoles_aggregate {
  aggregate: authRoles_aggregate_fields
  nodes: [authRoles!]!
}

"""
aggregate fields of "auth.roles"
"""
type authRoles_aggregate_fields {
  count(columns: [authRoles_select_column!], distinct: Boolean): Int!
  max: authRoles_max_fields
  min: authRoles_min_fields
}

"""
Boolean expression to filter rows from the table "auth.roles". All fields are combined with a logical 'AND'.
"""
input authRoles_bool_exp {
  _and: [authRoles_bool_exp!]
  _not: authRoles_bool_exp
  _or: [authRoles_bool_exp!]
  role: String_comparison_exp
  userRoles: authUserRoles_bool_exp
  usersByDefaultRole: users_bool_exp
}

"""
unique or primary key constraints on table "auth.roles"
"""
enum authRoles_constraint {
  """unique or primary key constraint"""
  roles_pkey
}

"""
input type for inserting data into table "auth.roles"
"""
input authRoles_insert_input {
  role: String
  userRoles: authUserRoles_arr_rel_insert_input
  usersByDefaultRole: users_arr_rel_insert_input
}

"""aggregate max on columns"""
type authRoles_max_fields {
  role: String
}

"""aggregate min on columns"""
type authRoles_min_fields {
  role: String
}

"""
response of any mutation on the table "auth.roles"
"""
type authRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authRoles!]!
}

"""
input type for inserting object relation for remote table "auth.roles"
"""
input authRoles_obj_rel_insert_input {
  data: authRoles_insert_input!

  """upsert condition"""
  on_conflict: authRoles_on_conflict
}

"""
on_conflict condition type for table "auth.roles"
"""
input authRoles_on_conflict {
  constraint: authRoles_constraint!
  update_columns: [authRoles_update_column!]! = []
  where: authRoles_bool_exp
}

"""Ordering options when selecting data from "auth.roles"."""
input authRoles_order_by {
  role: order_by
  userRoles_aggregate: authUserRoles_aggregate_order_by
  usersByDefaultRole_aggregate: users_aggregate_order_by
}

"""primary key columns input for table: authRoles"""
input authRoles_pk_columns_input {
  role: String!
}

"""
select columns of table "auth.roles"
"""
enum authRoles_select_column {
  """column name"""
  role
}

"""
input type for updating data in table "auth.roles"
"""
input authRoles_set_input {
  role: String
}

"""
update columns of table "auth.roles"
"""
enum authRoles_update_column {
  """column name"""
  role
}

"""
columns and relationships of "auth.user_providers"
"""
type authUserProviders {
  accessToken: String!
  createdAt: timestamptz!
  id: uuid!

  """An object relationship"""
  provider: authProviders!
  providerId: String!
  providerUserId: String!
  refreshToken: String
  updatedAt: timestamptz!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_providers"
"""
type authUserProviders_aggregate {
  aggregate: authUserProviders_aggregate_fields
  nodes: [authUserProviders!]!
}

"""
aggregate fields of "auth.user_providers"
"""
type authUserProviders_aggregate_fields {
  count(columns: [authUserProviders_select_column!], distinct: Boolean): Int!
  max: authUserProviders_max_fields
  min: authUserProviders_min_fields
}

"""
order by aggregate values of table "auth.user_providers"
"""
input authUserProviders_aggregate_order_by {
  count: order_by
  max: authUserProviders_max_order_by
  min: authUserProviders_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_providers"
"""
input authUserProviders_arr_rel_insert_input {
  data: [authUserProviders_insert_input!]!

  """upsert condition"""
  on_conflict: authUserProviders_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_providers". All fields are combined with a logical 'AND'.
"""
input authUserProviders_bool_exp {
  _and: [authUserProviders_bool_exp!]
  _not: authUserProviders_bool_exp
  _or: [authUserProviders_bool_exp!]
  accessToken: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  provider: authProviders_bool_exp
  providerId: String_comparison_exp
  providerUserId: String_comparison_exp
  refreshToken: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_providers"
"""
enum authUserProviders_constraint {
  """unique or primary key constraint"""
  user_providers_pkey

  """unique or primary key constraint"""
  user_providers_provider_id_provider_user_id_key

  """unique or primary key constraint"""
  user_providers_user_id_provider_id_key
}

"""
input type for inserting data into table "auth.user_providers"
"""
input authUserProviders_insert_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  provider: authProviders_obj_rel_insert_input
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserProviders_max_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by max() on columns of table "auth.user_providers"
"""
input authUserProviders_max_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserProviders_min_fields {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
order by min() on columns of table "auth.user_providers"
"""
input authUserProviders_min_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_providers"
"""
type authUserProviders_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserProviders!]!
}

"""
on_conflict condition type for table "auth.user_providers"
"""
input authUserProviders_on_conflict {
  constraint: authUserProviders_constraint!
  update_columns: [authUserProviders_update_column!]! = []
  where: authUserProviders_bool_exp
}

"""Ordering options when selecting data from "auth.user_providers"."""
input authUserProviders_order_by {
  accessToken: order_by
  createdAt: order_by
  id: order_by
  provider: authProviders_order_by
  providerId: order_by
  providerUserId: order_by
  refreshToken: order_by
  updatedAt: order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: authUserProviders"""
input authUserProviders_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_providers"
"""
enum authUserProviders_select_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_providers"
"""
input authUserProviders_set_input {
  accessToken: String
  createdAt: timestamptz
  id: uuid
  providerId: String
  providerUserId: String
  refreshToken: String
  updatedAt: timestamptz
  userId: uuid
}

"""
update columns of table "auth.user_providers"
"""
enum authUserProviders_update_column {
  """column name"""
  accessToken

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  providerId

  """column name"""
  providerUserId

  """column name"""
  refreshToken

  """column name"""
  updatedAt

  """column name"""
  userId
}

"""
columns and relationships of "auth.user_roles"
"""
type authUserRoles {
  createdAt: timestamptz!
  id: uuid!
  role: String!

  """An object relationship"""
  roleByRole: authRoles!

  """An object relationship"""
  user: users!
  userId: uuid!
}

"""
aggregated selection of "auth.user_roles"
"""
type authUserRoles_aggregate {
  aggregate: authUserRoles_aggregate_fields
  nodes: [authUserRoles!]!
}

"""
aggregate fields of "auth.user_roles"
"""
type authUserRoles_aggregate_fields {
  count(columns: [authUserRoles_select_column!], distinct: Boolean): Int!
  max: authUserRoles_max_fields
  min: authUserRoles_min_fields
}

"""
order by aggregate values of table "auth.user_roles"
"""
input authUserRoles_aggregate_order_by {
  count: order_by
  max: authUserRoles_max_order_by
  min: authUserRoles_min_order_by
}

"""
input type for inserting array relation for remote table "auth.user_roles"
"""
input authUserRoles_arr_rel_insert_input {
  data: [authUserRoles_insert_input!]!

  """upsert condition"""
  on_conflict: authUserRoles_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.user_roles". All fields are combined with a logical 'AND'.
"""
input authUserRoles_bool_exp {
  _and: [authUserRoles_bool_exp!]
  _not: authUserRoles_bool_exp
  _or: [authUserRoles_bool_exp!]
  createdAt: timestamptz_comparison_exp
  id: uuid_comparison_exp
  role: String_comparison_exp
  roleByRole: authRoles_bool_exp
  user: users_bool_exp
  userId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "auth.user_roles"
"""
enum authUserRoles_constraint {
  """unique or primary key constraint"""
  user_roles_pkey

  """unique or primary key constraint"""
  user_roles_user_id_role_key
}

"""
input type for inserting data into table "auth.user_roles"
"""
input authUserRoles_insert_input {
  createdAt: timestamptz
  id: uuid
  role: String
  roleByRole: authRoles_obj_rel_insert_input
  user: users_obj_rel_insert_input
  userId: uuid
}

"""aggregate max on columns"""
type authUserRoles_max_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by max() on columns of table "auth.user_roles"
"""
input authUserRoles_max_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""aggregate min on columns"""
type authUserRoles_min_fields {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
order by min() on columns of table "auth.user_roles"
"""
input authUserRoles_min_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  userId: order_by
}

"""
response of any mutation on the table "auth.user_roles"
"""
type authUserRoles_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [authUserRoles!]!
}

"""
on_conflict condition type for table "auth.user_roles"
"""
input authUserRoles_on_conflict {
  constraint: authUserRoles_constraint!
  update_columns: [authUserRoles_update_column!]! = []
  where: authUserRoles_bool_exp
}

"""Ordering options when selecting data from "auth.user_roles"."""
input authUserRoles_order_by {
  createdAt: order_by
  id: order_by
  role: order_by
  roleByRole: authRoles_order_by
  user: users_order_by
  userId: order_by
}

"""primary key columns input for table: authUserRoles"""
input authUserRoles_pk_columns_input {
  id: uuid!
}

"""
select columns of table "auth.user_roles"
"""
enum authUserRoles_select_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

"""
input type for updating data in table "auth.user_roles"
"""
input authUserRoles_set_input {
  createdAt: timestamptz
  id: uuid
  role: String
  userId: uuid
}

"""
update columns of table "auth.user_roles"
"""
enum authUserRoles_update_column {
  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  role

  """column name"""
  userId
}

"""
columns and relationships of "storage.buckets"
"""
type buckets {
  cacheControl: String
  createdAt: timestamptz!
  downloadExpiration: Int!

  """
  fetch data from the table: "storage.files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """An aggregate relationship"""
  files_aggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!
  id: String!
  maxUploadFileSize: Int!
  minUploadFileSize: Int!
  presignedUrlsEnabled: Boolean!
  updatedAt: timestamptz!
}

"""
aggregated selection of "storage.buckets"
"""
type buckets_aggregate {
  aggregate: buckets_aggregate_fields
  nodes: [buckets!]!
}

"""
aggregate fields of "storage.buckets"
"""
type buckets_aggregate_fields {
  avg: buckets_avg_fields
  count(columns: [buckets_select_column!], distinct: Boolean): Int!
  max: buckets_max_fields
  min: buckets_min_fields
  stddev: buckets_stddev_fields
  stddev_pop: buckets_stddev_pop_fields
  stddev_samp: buckets_stddev_samp_fields
  sum: buckets_sum_fields
  var_pop: buckets_var_pop_fields
  var_samp: buckets_var_samp_fields
  variance: buckets_variance_fields
}

"""aggregate avg on columns"""
type buckets_avg_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
Boolean expression to filter rows from the table "storage.buckets". All fields are combined with a logical 'AND'.
"""
input buckets_bool_exp {
  _and: [buckets_bool_exp!]
  _not: buckets_bool_exp
  _or: [buckets_bool_exp!]
  cacheControl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  downloadExpiration: Int_comparison_exp
  files: files_bool_exp
  id: String_comparison_exp
  maxUploadFileSize: Int_comparison_exp
  minUploadFileSize: Int_comparison_exp
  presignedUrlsEnabled: Boolean_comparison_exp
  updatedAt: timestamptz_comparison_exp
}

"""
unique or primary key constraints on table "storage.buckets"
"""
enum buckets_constraint {
  """unique or primary key constraint"""
  buckets_pkey
}

"""
input type for incrementing numeric columns in table "storage.buckets"
"""
input buckets_inc_input {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
input type for inserting data into table "storage.buckets"
"""
input buckets_insert_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  files: files_arr_rel_insert_input
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate max on columns"""
type buckets_max_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""aggregate min on columns"""
type buckets_min_fields {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  updatedAt: timestamptz
}

"""
response of any mutation on the table "storage.buckets"
"""
type buckets_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [buckets!]!
}

"""
input type for inserting object relation for remote table "storage.buckets"
"""
input buckets_obj_rel_insert_input {
  data: buckets_insert_input!

  """upsert condition"""
  on_conflict: buckets_on_conflict
}

"""
on_conflict condition type for table "storage.buckets"
"""
input buckets_on_conflict {
  constraint: buckets_constraint!
  update_columns: [buckets_update_column!]! = []
  where: buckets_bool_exp
}

"""Ordering options when selecting data from "storage.buckets"."""
input buckets_order_by {
  cacheControl: order_by
  createdAt: order_by
  downloadExpiration: order_by
  files_aggregate: files_aggregate_order_by
  id: order_by
  maxUploadFileSize: order_by
  minUploadFileSize: order_by
  presignedUrlsEnabled: order_by
  updatedAt: order_by
}

"""primary key columns input for table: buckets"""
input buckets_pk_columns_input {
  id: String!
}

"""
select columns of table "storage.buckets"
"""
enum buckets_select_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

"""
input type for updating data in table "storage.buckets"
"""
input buckets_set_input {
  cacheControl: String
  createdAt: timestamptz
  downloadExpiration: Int
  id: String
  maxUploadFileSize: Int
  minUploadFileSize: Int
  presignedUrlsEnabled: Boolean
  updatedAt: timestamptz
}

"""aggregate stddev on columns"""
type buckets_stddev_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_pop on columns"""
type buckets_stddev_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate stddev_samp on columns"""
type buckets_stddev_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate sum on columns"""
type buckets_sum_fields {
  downloadExpiration: Int
  maxUploadFileSize: Int
  minUploadFileSize: Int
}

"""
update columns of table "storage.buckets"
"""
enum buckets_update_column {
  """column name"""
  cacheControl

  """column name"""
  createdAt

  """column name"""
  downloadExpiration

  """column name"""
  id

  """column name"""
  maxUploadFileSize

  """column name"""
  minUploadFileSize

  """column name"""
  presignedUrlsEnabled

  """column name"""
  updatedAt
}

"""aggregate var_pop on columns"""
type buckets_var_pop_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate var_samp on columns"""
type buckets_var_samp_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""aggregate variance on columns"""
type buckets_variance_fields {
  downloadExpiration: Float
  maxUploadFileSize: Float
  minUploadFileSize: Float
}

"""
columns and relationships of "chatroom"
"""
type chatroom {
  UserId: String

  """An object relationship"""
  appUserByCreateuserid: app_user

  """An object relationship"""
  app_user: app_user

  """An array relationship"""
  chatroom_messages(
    """distinct select on columns"""
    distinct_on: [chatroom_message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_message_order_by!]

    """filter the rows returned"""
    where: chatroom_message_bool_exp
  ): [chatroom_message!]!

  """An aggregate relationship"""
  chatroom_messages_aggregate(
    """distinct select on columns"""
    distinct_on: [chatroom_message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_message_order_by!]

    """filter the rows returned"""
    where: chatroom_message_bool_exp
  ): chatroom_message_aggregate!
  createUserId: String
  createdAt: timestamp
  id: Int!
}

"""
aggregated selection of "chatroom"
"""
type chatroom_aggregate {
  aggregate: chatroom_aggregate_fields
  nodes: [chatroom!]!
}

"""
aggregate fields of "chatroom"
"""
type chatroom_aggregate_fields {
  avg: chatroom_avg_fields
  count(columns: [chatroom_select_column!], distinct: Boolean): Int!
  max: chatroom_max_fields
  min: chatroom_min_fields
  stddev: chatroom_stddev_fields
  stddev_pop: chatroom_stddev_pop_fields
  stddev_samp: chatroom_stddev_samp_fields
  sum: chatroom_sum_fields
  var_pop: chatroom_var_pop_fields
  var_samp: chatroom_var_samp_fields
  variance: chatroom_variance_fields
}

"""
order by aggregate values of table "chatroom"
"""
input chatroom_aggregate_order_by {
  avg: chatroom_avg_order_by
  count: order_by
  max: chatroom_max_order_by
  min: chatroom_min_order_by
  stddev: chatroom_stddev_order_by
  stddev_pop: chatroom_stddev_pop_order_by
  stddev_samp: chatroom_stddev_samp_order_by
  sum: chatroom_sum_order_by
  var_pop: chatroom_var_pop_order_by
  var_samp: chatroom_var_samp_order_by
  variance: chatroom_variance_order_by
}

"""
input type for inserting array relation for remote table "chatroom"
"""
input chatroom_arr_rel_insert_input {
  data: [chatroom_insert_input!]!

  """upsert condition"""
  on_conflict: chatroom_on_conflict
}

"""aggregate avg on columns"""
type chatroom_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "chatroom"
"""
input chatroom_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "chatroom". All fields are combined with a logical 'AND'.
"""
input chatroom_bool_exp {
  UserId: String_comparison_exp
  _and: [chatroom_bool_exp!]
  _not: chatroom_bool_exp
  _or: [chatroom_bool_exp!]
  appUserByCreateuserid: app_user_bool_exp
  app_user: app_user_bool_exp
  chatroom_messages: chatroom_message_bool_exp
  createUserId: String_comparison_exp
  createdAt: timestamp_comparison_exp
  id: Int_comparison_exp
}

"""
unique or primary key constraints on table "chatroom"
"""
enum chatroom_constraint {
  """unique or primary key constraint"""
  chatroom_pkey
}

"""
input type for incrementing numeric columns in table "chatroom"
"""
input chatroom_inc_input {
  id: Int
}

"""
input type for inserting data into table "chatroom"
"""
input chatroom_insert_input {
  UserId: String
  appUserByCreateuserid: app_user_obj_rel_insert_input
  app_user: app_user_obj_rel_insert_input
  chatroom_messages: chatroom_message_arr_rel_insert_input
  createUserId: String
  createdAt: timestamp
  id: Int
}

"""aggregate max on columns"""
type chatroom_max_fields {
  UserId: String
  createUserId: String
  createdAt: timestamp
  id: Int
}

"""
order by max() on columns of table "chatroom"
"""
input chatroom_max_order_by {
  UserId: order_by
  createUserId: order_by
  createdAt: order_by
  id: order_by
}

"""
columns and relationships of "chatroom_message"
"""
type chatroom_message {
  """An object relationship"""
  app_user: app_user

  """An object relationship"""
  chatroom: chatroom
  chatroomId: Int
  content: String
  createdAt: timestamp
  id: Int!
  userId: String
}

"""
aggregated selection of "chatroom_message"
"""
type chatroom_message_aggregate {
  aggregate: chatroom_message_aggregate_fields
  nodes: [chatroom_message!]!
}

"""
aggregate fields of "chatroom_message"
"""
type chatroom_message_aggregate_fields {
  avg: chatroom_message_avg_fields
  count(columns: [chatroom_message_select_column!], distinct: Boolean): Int!
  max: chatroom_message_max_fields
  min: chatroom_message_min_fields
  stddev: chatroom_message_stddev_fields
  stddev_pop: chatroom_message_stddev_pop_fields
  stddev_samp: chatroom_message_stddev_samp_fields
  sum: chatroom_message_sum_fields
  var_pop: chatroom_message_var_pop_fields
  var_samp: chatroom_message_var_samp_fields
  variance: chatroom_message_variance_fields
}

"""
order by aggregate values of table "chatroom_message"
"""
input chatroom_message_aggregate_order_by {
  avg: chatroom_message_avg_order_by
  count: order_by
  max: chatroom_message_max_order_by
  min: chatroom_message_min_order_by
  stddev: chatroom_message_stddev_order_by
  stddev_pop: chatroom_message_stddev_pop_order_by
  stddev_samp: chatroom_message_stddev_samp_order_by
  sum: chatroom_message_sum_order_by
  var_pop: chatroom_message_var_pop_order_by
  var_samp: chatroom_message_var_samp_order_by
  variance: chatroom_message_variance_order_by
}

"""
input type for inserting array relation for remote table "chatroom_message"
"""
input chatroom_message_arr_rel_insert_input {
  data: [chatroom_message_insert_input!]!

  """upsert condition"""
  on_conflict: chatroom_message_on_conflict
}

"""aggregate avg on columns"""
type chatroom_message_avg_fields {
  chatroomId: Float
  id: Float
}

"""
order by avg() on columns of table "chatroom_message"
"""
input chatroom_message_avg_order_by {
  chatroomId: order_by
  id: order_by
}

"""
Boolean expression to filter rows from the table "chatroom_message". All fields are combined with a logical 'AND'.
"""
input chatroom_message_bool_exp {
  _and: [chatroom_message_bool_exp!]
  _not: chatroom_message_bool_exp
  _or: [chatroom_message_bool_exp!]
  app_user: app_user_bool_exp
  chatroom: chatroom_bool_exp
  chatroomId: Int_comparison_exp
  content: String_comparison_exp
  createdAt: timestamp_comparison_exp
  id: Int_comparison_exp
  userId: String_comparison_exp
}

"""
unique or primary key constraints on table "chatroom_message"
"""
enum chatroom_message_constraint {
  """unique or primary key constraint"""
  chatroom_message_pkey
}

"""
input type for incrementing numeric columns in table "chatroom_message"
"""
input chatroom_message_inc_input {
  chatroomId: Int
  id: Int
}

"""
input type for inserting data into table "chatroom_message"
"""
input chatroom_message_insert_input {
  app_user: app_user_obj_rel_insert_input
  chatroom: chatroom_obj_rel_insert_input
  chatroomId: Int
  content: String
  createdAt: timestamp
  id: Int
  userId: String
}

"""aggregate max on columns"""
type chatroom_message_max_fields {
  chatroomId: Int
  content: String
  createdAt: timestamp
  id: Int
  userId: String
}

"""
order by max() on columns of table "chatroom_message"
"""
input chatroom_message_max_order_by {
  chatroomId: order_by
  content: order_by
  createdAt: order_by
  id: order_by
  userId: order_by
}

"""aggregate min on columns"""
type chatroom_message_min_fields {
  chatroomId: Int
  content: String
  createdAt: timestamp
  id: Int
  userId: String
}

"""
order by min() on columns of table "chatroom_message"
"""
input chatroom_message_min_order_by {
  chatroomId: order_by
  content: order_by
  createdAt: order_by
  id: order_by
  userId: order_by
}

"""
response of any mutation on the table "chatroom_message"
"""
type chatroom_message_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chatroom_message!]!
}

"""
on_conflict condition type for table "chatroom_message"
"""
input chatroom_message_on_conflict {
  constraint: chatroom_message_constraint!
  update_columns: [chatroom_message_update_column!]! = []
  where: chatroom_message_bool_exp
}

"""Ordering options when selecting data from "chatroom_message"."""
input chatroom_message_order_by {
  app_user: app_user_order_by
  chatroom: chatroom_order_by
  chatroomId: order_by
  content: order_by
  createdAt: order_by
  id: order_by
  userId: order_by
}

"""primary key columns input for table: chatroom_message"""
input chatroom_message_pk_columns_input {
  id: Int!
}

"""
select columns of table "chatroom_message"
"""
enum chatroom_message_select_column {
  """column name"""
  chatroomId

  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  userId
}

"""
input type for updating data in table "chatroom_message"
"""
input chatroom_message_set_input {
  chatroomId: Int
  content: String
  createdAt: timestamp
  id: Int
  userId: String
}

"""aggregate stddev on columns"""
type chatroom_message_stddev_fields {
  chatroomId: Float
  id: Float
}

"""
order by stddev() on columns of table "chatroom_message"
"""
input chatroom_message_stddev_order_by {
  chatroomId: order_by
  id: order_by
}

"""aggregate stddev_pop on columns"""
type chatroom_message_stddev_pop_fields {
  chatroomId: Float
  id: Float
}

"""
order by stddev_pop() on columns of table "chatroom_message"
"""
input chatroom_message_stddev_pop_order_by {
  chatroomId: order_by
  id: order_by
}

"""aggregate stddev_samp on columns"""
type chatroom_message_stddev_samp_fields {
  chatroomId: Float
  id: Float
}

"""
order by stddev_samp() on columns of table "chatroom_message"
"""
input chatroom_message_stddev_samp_order_by {
  chatroomId: order_by
  id: order_by
}

"""aggregate sum on columns"""
type chatroom_message_sum_fields {
  chatroomId: Int
  id: Int
}

"""
order by sum() on columns of table "chatroom_message"
"""
input chatroom_message_sum_order_by {
  chatroomId: order_by
  id: order_by
}

"""
update columns of table "chatroom_message"
"""
enum chatroom_message_update_column {
  """column name"""
  chatroomId

  """column name"""
  content

  """column name"""
  createdAt

  """column name"""
  id

  """column name"""
  userId
}

"""aggregate var_pop on columns"""
type chatroom_message_var_pop_fields {
  chatroomId: Float
  id: Float
}

"""
order by var_pop() on columns of table "chatroom_message"
"""
input chatroom_message_var_pop_order_by {
  chatroomId: order_by
  id: order_by
}

"""aggregate var_samp on columns"""
type chatroom_message_var_samp_fields {
  chatroomId: Float
  id: Float
}

"""
order by var_samp() on columns of table "chatroom_message"
"""
input chatroom_message_var_samp_order_by {
  chatroomId: order_by
  id: order_by
}

"""aggregate variance on columns"""
type chatroom_message_variance_fields {
  chatroomId: Float
  id: Float
}

"""
order by variance() on columns of table "chatroom_message"
"""
input chatroom_message_variance_order_by {
  chatroomId: order_by
  id: order_by
}

"""aggregate min on columns"""
type chatroom_min_fields {
  UserId: String
  createUserId: String
  createdAt: timestamp
  id: Int
}

"""
order by min() on columns of table "chatroom"
"""
input chatroom_min_order_by {
  UserId: order_by
  createUserId: order_by
  createdAt: order_by
  id: order_by
}

"""
response of any mutation on the table "chatroom"
"""
type chatroom_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [chatroom!]!
}

"""
input type for inserting object relation for remote table "chatroom"
"""
input chatroom_obj_rel_insert_input {
  data: chatroom_insert_input!

  """upsert condition"""
  on_conflict: chatroom_on_conflict
}

"""
on_conflict condition type for table "chatroom"
"""
input chatroom_on_conflict {
  constraint: chatroom_constraint!
  update_columns: [chatroom_update_column!]! = []
  where: chatroom_bool_exp
}

"""Ordering options when selecting data from "chatroom"."""
input chatroom_order_by {
  UserId: order_by
  appUserByCreateuserid: app_user_order_by
  app_user: app_user_order_by
  chatroom_messages_aggregate: chatroom_message_aggregate_order_by
  createUserId: order_by
  createdAt: order_by
  id: order_by
}

"""primary key columns input for table: chatroom"""
input chatroom_pk_columns_input {
  id: Int!
}

"""
select columns of table "chatroom"
"""
enum chatroom_select_column {
  """column name"""
  UserId

  """column name"""
  createUserId

  """column name"""
  createdAt

  """column name"""
  id
}

"""
input type for updating data in table "chatroom"
"""
input chatroom_set_input {
  UserId: String
  createUserId: String
  createdAt: timestamp
  id: Int
}

"""aggregate stddev on columns"""
type chatroom_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "chatroom"
"""
input chatroom_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type chatroom_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "chatroom"
"""
input chatroom_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type chatroom_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "chatroom"
"""
input chatroom_stddev_samp_order_by {
  id: order_by
}

"""aggregate sum on columns"""
type chatroom_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "chatroom"
"""
input chatroom_sum_order_by {
  id: order_by
}

"""
update columns of table "chatroom"
"""
enum chatroom_update_column {
  """column name"""
  UserId

  """column name"""
  createUserId

  """column name"""
  createdAt

  """column name"""
  id
}

"""aggregate var_pop on columns"""
type chatroom_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "chatroom"
"""
input chatroom_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type chatroom_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "chatroom"
"""
input chatroom_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type chatroom_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "chatroom"
"""
input chatroom_variance_order_by {
  id: order_by
}

scalar citext

"""
Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'.
"""
input citext_comparison_exp {
  _eq: citext
  _gt: citext
  _gte: citext

  """does the column match the given case-insensitive pattern"""
  _ilike: citext
  _in: [citext!]

  """
  does the column match the given POSIX regular expression, case insensitive
  """
  _iregex: citext
  _is_null: Boolean

  """does the column match the given pattern"""
  _like: citext
  _lt: citext
  _lte: citext
  _neq: citext

  """does the column NOT match the given case-insensitive pattern"""
  _nilike: citext
  _nin: [citext!]

  """
  does the column NOT match the given POSIX regular expression, case insensitive
  """
  _niregex: citext

  """does the column NOT match the given pattern"""
  _nlike: citext

  """
  does the column NOT match the given POSIX regular expression, case sensitive
  """
  _nregex: citext

  """does the column NOT match the given SQL regular expression"""
  _nsimilar: citext

  """
  does the column match the given POSIX regular expression, case sensitive
  """
  _regex: citext

  """does the column match the given SQL regular expression"""
  _similar: citext
}

"""
columns and relationships of "clothing"
"""
type clothing {
  """An object relationship"""
  app_user: app_user
  availability: String
  brand: String

  """An array relationship"""
  clothing_statuses(
    """distinct select on columns"""
    distinct_on: [clothing_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_status_order_by!]

    """filter the rows returned"""
    where: clothing_status_bool_exp
  ): [clothing_status!]!

  """An aggregate relationship"""
  clothing_statuses_aggregate(
    """distinct select on columns"""
    distinct_on: [clothing_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_status_order_by!]

    """filter the rows returned"""
    where: clothing_status_bool_exp
  ): clothing_status_aggregate!
  color: String
  createdBy: String
  id: Int!
  image(
    """JSON select path"""
    path: String
  ): jsonb
  name: String

  """An array relationship"""
  ratings(
    """distinct select on columns"""
    distinct_on: [rating_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rating_order_by!]

    """filter the rows returned"""
    where: rating_bool_exp
  ): [rating!]!

  """An aggregate relationship"""
  ratings_aggregate(
    """distinct select on columns"""
    distinct_on: [rating_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rating_order_by!]

    """filter the rows returned"""
    where: rating_bool_exp
  ): rating_aggregate!
  size: String
  type: String
  updatedAt: timestamp

  """An array relationship"""
  user_wardrobes(
    """distinct select on columns"""
    distinct_on: [user_wardrobe_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wardrobe_order_by!]

    """filter the rows returned"""
    where: user_wardrobe_bool_exp
  ): [user_wardrobe!]!

  """An aggregate relationship"""
  user_wardrobes_aggregate(
    """distinct select on columns"""
    distinct_on: [user_wardrobe_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wardrobe_order_by!]

    """filter the rows returned"""
    where: user_wardrobe_bool_exp
  ): user_wardrobe_aggregate!

  """An array relationship"""
  user_wishlists(
    """distinct select on columns"""
    distinct_on: [user_wishlist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wishlist_order_by!]

    """filter the rows returned"""
    where: user_wishlist_bool_exp
  ): [user_wishlist!]!

  """An aggregate relationship"""
  user_wishlists_aggregate(
    """distinct select on columns"""
    distinct_on: [user_wishlist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wishlist_order_by!]

    """filter the rows returned"""
    where: user_wishlist_bool_exp
  ): user_wishlist_aggregate!
}

"""
aggregated selection of "clothing"
"""
type clothing_aggregate {
  aggregate: clothing_aggregate_fields
  nodes: [clothing!]!
}

"""
aggregate fields of "clothing"
"""
type clothing_aggregate_fields {
  avg: clothing_avg_fields
  count(columns: [clothing_select_column!], distinct: Boolean): Int!
  max: clothing_max_fields
  min: clothing_min_fields
  stddev: clothing_stddev_fields
  stddev_pop: clothing_stddev_pop_fields
  stddev_samp: clothing_stddev_samp_fields
  sum: clothing_sum_fields
  var_pop: clothing_var_pop_fields
  var_samp: clothing_var_samp_fields
  variance: clothing_variance_fields
}

"""
order by aggregate values of table "clothing"
"""
input clothing_aggregate_order_by {
  avg: clothing_avg_order_by
  count: order_by
  max: clothing_max_order_by
  min: clothing_min_order_by
  stddev: clothing_stddev_order_by
  stddev_pop: clothing_stddev_pop_order_by
  stddev_samp: clothing_stddev_samp_order_by
  sum: clothing_sum_order_by
  var_pop: clothing_var_pop_order_by
  var_samp: clothing_var_samp_order_by
  variance: clothing_variance_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input clothing_append_input {
  image: jsonb
}

"""
input type for inserting array relation for remote table "clothing"
"""
input clothing_arr_rel_insert_input {
  data: [clothing_insert_input!]!

  """upsert condition"""
  on_conflict: clothing_on_conflict
}

"""aggregate avg on columns"""
type clothing_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "clothing"
"""
input clothing_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "clothing". All fields are combined with a logical 'AND'.
"""
input clothing_bool_exp {
  _and: [clothing_bool_exp!]
  _not: clothing_bool_exp
  _or: [clothing_bool_exp!]
  app_user: app_user_bool_exp
  availability: String_comparison_exp
  brand: String_comparison_exp
  clothing_statuses: clothing_status_bool_exp
  color: String_comparison_exp
  createdBy: String_comparison_exp
  id: Int_comparison_exp
  image: jsonb_comparison_exp
  name: String_comparison_exp
  ratings: rating_bool_exp
  size: String_comparison_exp
  type: String_comparison_exp
  updatedAt: timestamp_comparison_exp
  user_wardrobes: user_wardrobe_bool_exp
  user_wishlists: user_wishlist_bool_exp
}

"""
unique or primary key constraints on table "clothing"
"""
enum clothing_constraint {
  """unique or primary key constraint"""
  clothing_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input clothing_delete_at_path_input {
  image: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input clothing_delete_elem_input {
  image: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input clothing_delete_key_input {
  image: String
}

"""
input type for incrementing numeric columns in table "clothing"
"""
input clothing_inc_input {
  id: Int
}

"""
input type for inserting data into table "clothing"
"""
input clothing_insert_input {
  app_user: app_user_obj_rel_insert_input
  availability: String
  brand: String
  clothing_statuses: clothing_status_arr_rel_insert_input
  color: String
  createdBy: String
  id: Int
  image: jsonb
  name: String
  ratings: rating_arr_rel_insert_input
  size: String
  type: String
  updatedAt: timestamp
  user_wardrobes: user_wardrobe_arr_rel_insert_input
  user_wishlists: user_wishlist_arr_rel_insert_input
}

"""aggregate max on columns"""
type clothing_max_fields {
  availability: String
  brand: String
  color: String
  createdBy: String
  id: Int
  name: String
  size: String
  type: String
  updatedAt: timestamp
}

"""
order by max() on columns of table "clothing"
"""
input clothing_max_order_by {
  availability: order_by
  brand: order_by
  color: order_by
  createdBy: order_by
  id: order_by
  name: order_by
  size: order_by
  type: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type clothing_min_fields {
  availability: String
  brand: String
  color: String
  createdBy: String
  id: Int
  name: String
  size: String
  type: String
  updatedAt: timestamp
}

"""
order by min() on columns of table "clothing"
"""
input clothing_min_order_by {
  availability: order_by
  brand: order_by
  color: order_by
  createdBy: order_by
  id: order_by
  name: order_by
  size: order_by
  type: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "clothing"
"""
type clothing_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [clothing!]!
}

"""
input type for inserting object relation for remote table "clothing"
"""
input clothing_obj_rel_insert_input {
  data: clothing_insert_input!

  """upsert condition"""
  on_conflict: clothing_on_conflict
}

"""
on_conflict condition type for table "clothing"
"""
input clothing_on_conflict {
  constraint: clothing_constraint!
  update_columns: [clothing_update_column!]! = []
  where: clothing_bool_exp
}

"""Ordering options when selecting data from "clothing"."""
input clothing_order_by {
  app_user: app_user_order_by
  availability: order_by
  brand: order_by
  clothing_statuses_aggregate: clothing_status_aggregate_order_by
  color: order_by
  createdBy: order_by
  id: order_by
  image: order_by
  name: order_by
  ratings_aggregate: rating_aggregate_order_by
  size: order_by
  type: order_by
  updatedAt: order_by
  user_wardrobes_aggregate: user_wardrobe_aggregate_order_by
  user_wishlists_aggregate: user_wishlist_aggregate_order_by
}

"""primary key columns input for table: clothing"""
input clothing_pk_columns_input {
  id: Int!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input clothing_prepend_input {
  image: jsonb
}

"""
select columns of table "clothing"
"""
enum clothing_select_column {
  """column name"""
  availability

  """column name"""
  brand

  """column name"""
  color

  """column name"""
  createdBy

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  size

  """column name"""
  type

  """column name"""
  updatedAt
}

"""
input type for updating data in table "clothing"
"""
input clothing_set_input {
  availability: String
  brand: String
  color: String
  createdBy: String
  id: Int
  image: jsonb
  name: String
  size: String
  type: String
  updatedAt: timestamp
}

"""
columns and relationships of "clothing_status"
"""
type clothing_status {
  """An object relationship"""
  appUserByOwnerid: app_user

  """An object relationship"""
  app_user: app_user
  borrowedTo: String

  """An object relationship"""
  clothing: clothing
  clothingId: Int
  ownerId: String
  status: String
}

"""
aggregated selection of "clothing_status"
"""
type clothing_status_aggregate {
  aggregate: clothing_status_aggregate_fields
  nodes: [clothing_status!]!
}

"""
aggregate fields of "clothing_status"
"""
type clothing_status_aggregate_fields {
  avg: clothing_status_avg_fields
  count(columns: [clothing_status_select_column!], distinct: Boolean): Int!
  max: clothing_status_max_fields
  min: clothing_status_min_fields
  stddev: clothing_status_stddev_fields
  stddev_pop: clothing_status_stddev_pop_fields
  stddev_samp: clothing_status_stddev_samp_fields
  sum: clothing_status_sum_fields
  var_pop: clothing_status_var_pop_fields
  var_samp: clothing_status_var_samp_fields
  variance: clothing_status_variance_fields
}

"""
order by aggregate values of table "clothing_status"
"""
input clothing_status_aggregate_order_by {
  avg: clothing_status_avg_order_by
  count: order_by
  max: clothing_status_max_order_by
  min: clothing_status_min_order_by
  stddev: clothing_status_stddev_order_by
  stddev_pop: clothing_status_stddev_pop_order_by
  stddev_samp: clothing_status_stddev_samp_order_by
  sum: clothing_status_sum_order_by
  var_pop: clothing_status_var_pop_order_by
  var_samp: clothing_status_var_samp_order_by
  variance: clothing_status_variance_order_by
}

"""
input type for inserting array relation for remote table "clothing_status"
"""
input clothing_status_arr_rel_insert_input {
  data: [clothing_status_insert_input!]!
}

"""aggregate avg on columns"""
type clothing_status_avg_fields {
  clothingId: Float
}

"""
order by avg() on columns of table "clothing_status"
"""
input clothing_status_avg_order_by {
  clothingId: order_by
}

"""
Boolean expression to filter rows from the table "clothing_status". All fields are combined with a logical 'AND'.
"""
input clothing_status_bool_exp {
  _and: [clothing_status_bool_exp!]
  _not: clothing_status_bool_exp
  _or: [clothing_status_bool_exp!]
  appUserByOwnerid: app_user_bool_exp
  app_user: app_user_bool_exp
  borrowedTo: String_comparison_exp
  clothing: clothing_bool_exp
  clothingId: Int_comparison_exp
  ownerId: String_comparison_exp
  status: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "clothing_status"
"""
input clothing_status_inc_input {
  clothingId: Int
}

"""
input type for inserting data into table "clothing_status"
"""
input clothing_status_insert_input {
  appUserByOwnerid: app_user_obj_rel_insert_input
  app_user: app_user_obj_rel_insert_input
  borrowedTo: String
  clothing: clothing_obj_rel_insert_input
  clothingId: Int
  ownerId: String
  status: String
}

"""aggregate max on columns"""
type clothing_status_max_fields {
  borrowedTo: String
  clothingId: Int
  ownerId: String
  status: String
}

"""
order by max() on columns of table "clothing_status"
"""
input clothing_status_max_order_by {
  borrowedTo: order_by
  clothingId: order_by
  ownerId: order_by
  status: order_by
}

"""aggregate min on columns"""
type clothing_status_min_fields {
  borrowedTo: String
  clothingId: Int
  ownerId: String
  status: String
}

"""
order by min() on columns of table "clothing_status"
"""
input clothing_status_min_order_by {
  borrowedTo: order_by
  clothingId: order_by
  ownerId: order_by
  status: order_by
}

"""
response of any mutation on the table "clothing_status"
"""
type clothing_status_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [clothing_status!]!
}

"""Ordering options when selecting data from "clothing_status"."""
input clothing_status_order_by {
  appUserByOwnerid: app_user_order_by
  app_user: app_user_order_by
  borrowedTo: order_by
  clothing: clothing_order_by
  clothingId: order_by
  ownerId: order_by
  status: order_by
}

"""
select columns of table "clothing_status"
"""
enum clothing_status_select_column {
  """column name"""
  borrowedTo

  """column name"""
  clothingId

  """column name"""
  ownerId

  """column name"""
  status
}

"""
input type for updating data in table "clothing_status"
"""
input clothing_status_set_input {
  borrowedTo: String
  clothingId: Int
  ownerId: String
  status: String
}

"""aggregate stddev on columns"""
type clothing_status_stddev_fields {
  clothingId: Float
}

"""
order by stddev() on columns of table "clothing_status"
"""
input clothing_status_stddev_order_by {
  clothingId: order_by
}

"""aggregate stddev_pop on columns"""
type clothing_status_stddev_pop_fields {
  clothingId: Float
}

"""
order by stddev_pop() on columns of table "clothing_status"
"""
input clothing_status_stddev_pop_order_by {
  clothingId: order_by
}

"""aggregate stddev_samp on columns"""
type clothing_status_stddev_samp_fields {
  clothingId: Float
}

"""
order by stddev_samp() on columns of table "clothing_status"
"""
input clothing_status_stddev_samp_order_by {
  clothingId: order_by
}

"""aggregate sum on columns"""
type clothing_status_sum_fields {
  clothingId: Int
}

"""
order by sum() on columns of table "clothing_status"
"""
input clothing_status_sum_order_by {
  clothingId: order_by
}

"""aggregate var_pop on columns"""
type clothing_status_var_pop_fields {
  clothingId: Float
}

"""
order by var_pop() on columns of table "clothing_status"
"""
input clothing_status_var_pop_order_by {
  clothingId: order_by
}

"""aggregate var_samp on columns"""
type clothing_status_var_samp_fields {
  clothingId: Float
}

"""
order by var_samp() on columns of table "clothing_status"
"""
input clothing_status_var_samp_order_by {
  clothingId: order_by
}

"""aggregate variance on columns"""
type clothing_status_variance_fields {
  clothingId: Float
}

"""
order by variance() on columns of table "clothing_status"
"""
input clothing_status_variance_order_by {
  clothingId: order_by
}

"""aggregate stddev on columns"""
type clothing_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "clothing"
"""
input clothing_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type clothing_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "clothing"
"""
input clothing_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type clothing_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "clothing"
"""
input clothing_stddev_samp_order_by {
  id: order_by
}

"""aggregate sum on columns"""
type clothing_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "clothing"
"""
input clothing_sum_order_by {
  id: order_by
}

"""
update columns of table "clothing"
"""
enum clothing_update_column {
  """column name"""
  availability

  """column name"""
  brand

  """column name"""
  color

  """column name"""
  createdBy

  """column name"""
  id

  """column name"""
  image

  """column name"""
  name

  """column name"""
  size

  """column name"""
  type

  """column name"""
  updatedAt
}

"""aggregate var_pop on columns"""
type clothing_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "clothing"
"""
input clothing_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type clothing_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "clothing"
"""
input clothing_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type clothing_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "clothing"
"""
input clothing_variance_order_by {
  id: order_by
}

"""
columns and relationships of "storage.files"
"""
type files {
  """An object relationship"""
  bucket: buckets!
  bucketId: String!
  createdAt: timestamptz!
  etag: String
  id: uuid!
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz!
  uploadedByUserId: uuid
}

"""
aggregated selection of "storage.files"
"""
type files_aggregate {
  aggregate: files_aggregate_fields
  nodes: [files!]!
}

"""
aggregate fields of "storage.files"
"""
type files_aggregate_fields {
  avg: files_avg_fields
  count(columns: [files_select_column!], distinct: Boolean): Int!
  max: files_max_fields
  min: files_min_fields
  stddev: files_stddev_fields
  stddev_pop: files_stddev_pop_fields
  stddev_samp: files_stddev_samp_fields
  sum: files_sum_fields
  var_pop: files_var_pop_fields
  var_samp: files_var_samp_fields
  variance: files_variance_fields
}

"""
order by aggregate values of table "storage.files"
"""
input files_aggregate_order_by {
  avg: files_avg_order_by
  count: order_by
  max: files_max_order_by
  min: files_min_order_by
  stddev: files_stddev_order_by
  stddev_pop: files_stddev_pop_order_by
  stddev_samp: files_stddev_samp_order_by
  sum: files_sum_order_by
  var_pop: files_var_pop_order_by
  var_samp: files_var_samp_order_by
  variance: files_variance_order_by
}

"""
input type for inserting array relation for remote table "storage.files"
"""
input files_arr_rel_insert_input {
  data: [files_insert_input!]!

  """upsert condition"""
  on_conflict: files_on_conflict
}

"""aggregate avg on columns"""
type files_avg_fields {
  size: Float
}

"""
order by avg() on columns of table "storage.files"
"""
input files_avg_order_by {
  size: order_by
}

"""
Boolean expression to filter rows from the table "storage.files". All fields are combined with a logical 'AND'.
"""
input files_bool_exp {
  _and: [files_bool_exp!]
  _not: files_bool_exp
  _or: [files_bool_exp!]
  bucket: buckets_bool_exp
  bucketId: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  etag: String_comparison_exp
  id: uuid_comparison_exp
  isUploaded: Boolean_comparison_exp
  mimeType: String_comparison_exp
  name: String_comparison_exp
  size: Int_comparison_exp
  updatedAt: timestamptz_comparison_exp
  uploadedByUserId: uuid_comparison_exp
}

"""
unique or primary key constraints on table "storage.files"
"""
enum files_constraint {
  """unique or primary key constraint"""
  files_pkey
}

"""
input type for incrementing numeric columns in table "storage.files"
"""
input files_inc_input {
  size: Int
}

"""
input type for inserting data into table "storage.files"
"""
input files_insert_input {
  bucket: buckets_obj_rel_insert_input
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate max on columns"""
type files_max_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by max() on columns of table "storage.files"
"""
input files_max_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""aggregate min on columns"""
type files_min_fields {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""
order by min() on columns of table "storage.files"
"""
input files_min_order_by {
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""
response of any mutation on the table "storage.files"
"""
type files_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [files!]!
}

"""
on_conflict condition type for table "storage.files"
"""
input files_on_conflict {
  constraint: files_constraint!
  update_columns: [files_update_column!]! = []
  where: files_bool_exp
}

"""Ordering options when selecting data from "storage.files"."""
input files_order_by {
  bucket: buckets_order_by
  bucketId: order_by
  createdAt: order_by
  etag: order_by
  id: order_by
  isUploaded: order_by
  mimeType: order_by
  name: order_by
  size: order_by
  updatedAt: order_by
  uploadedByUserId: order_by
}

"""primary key columns input for table: files"""
input files_pk_columns_input {
  id: uuid!
}

"""
select columns of table "storage.files"
"""
enum files_select_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

"""
input type for updating data in table "storage.files"
"""
input files_set_input {
  bucketId: String
  createdAt: timestamptz
  etag: String
  id: uuid
  isUploaded: Boolean
  mimeType: String
  name: String
  size: Int
  updatedAt: timestamptz
  uploadedByUserId: uuid
}

"""aggregate stddev on columns"""
type files_stddev_fields {
  size: Float
}

"""
order by stddev() on columns of table "storage.files"
"""
input files_stddev_order_by {
  size: order_by
}

"""aggregate stddev_pop on columns"""
type files_stddev_pop_fields {
  size: Float
}

"""
order by stddev_pop() on columns of table "storage.files"
"""
input files_stddev_pop_order_by {
  size: order_by
}

"""aggregate stddev_samp on columns"""
type files_stddev_samp_fields {
  size: Float
}

"""
order by stddev_samp() on columns of table "storage.files"
"""
input files_stddev_samp_order_by {
  size: order_by
}

"""aggregate sum on columns"""
type files_sum_fields {
  size: Int
}

"""
order by sum() on columns of table "storage.files"
"""
input files_sum_order_by {
  size: order_by
}

"""
update columns of table "storage.files"
"""
enum files_update_column {
  """column name"""
  bucketId

  """column name"""
  createdAt

  """column name"""
  etag

  """column name"""
  id

  """column name"""
  isUploaded

  """column name"""
  mimeType

  """column name"""
  name

  """column name"""
  size

  """column name"""
  updatedAt

  """column name"""
  uploadedByUserId
}

"""aggregate var_pop on columns"""
type files_var_pop_fields {
  size: Float
}

"""
order by var_pop() on columns of table "storage.files"
"""
input files_var_pop_order_by {
  size: order_by
}

"""aggregate var_samp on columns"""
type files_var_samp_fields {
  size: Float
}

"""
order by var_samp() on columns of table "storage.files"
"""
input files_var_samp_order_by {
  size: order_by
}

"""aggregate variance on columns"""
type files_variance_fields {
  size: Float
}

"""
order by variance() on columns of table "storage.files"
"""
input files_variance_order_by {
  size: order_by
}

"""
columns and relationships of "group"
"""
type group {
  """An object relationship"""
  app_user: app_user
  creatorId: String

  """An array relationship"""
  group_members(
    """distinct select on columns"""
    distinct_on: [group_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_member_order_by!]

    """filter the rows returned"""
    where: group_member_bool_exp
  ): [group_member!]!

  """An aggregate relationship"""
  group_members_aggregate(
    """distinct select on columns"""
    distinct_on: [group_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_member_order_by!]

    """filter the rows returned"""
    where: group_member_bool_exp
  ): group_member_aggregate!
  id: Int!
  name: String
}

"""
aggregated selection of "group"
"""
type group_aggregate {
  aggregate: group_aggregate_fields
  nodes: [group!]!
}

"""
aggregate fields of "group"
"""
type group_aggregate_fields {
  avg: group_avg_fields
  count(columns: [group_select_column!], distinct: Boolean): Int!
  max: group_max_fields
  min: group_min_fields
  stddev: group_stddev_fields
  stddev_pop: group_stddev_pop_fields
  stddev_samp: group_stddev_samp_fields
  sum: group_sum_fields
  var_pop: group_var_pop_fields
  var_samp: group_var_samp_fields
  variance: group_variance_fields
}

"""
order by aggregate values of table "group"
"""
input group_aggregate_order_by {
  avg: group_avg_order_by
  count: order_by
  max: group_max_order_by
  min: group_min_order_by
  stddev: group_stddev_order_by
  stddev_pop: group_stddev_pop_order_by
  stddev_samp: group_stddev_samp_order_by
  sum: group_sum_order_by
  var_pop: group_var_pop_order_by
  var_samp: group_var_samp_order_by
  variance: group_variance_order_by
}

"""
input type for inserting array relation for remote table "group"
"""
input group_arr_rel_insert_input {
  data: [group_insert_input!]!

  """upsert condition"""
  on_conflict: group_on_conflict
}

"""aggregate avg on columns"""
type group_avg_fields {
  id: Float
}

"""
order by avg() on columns of table "group"
"""
input group_avg_order_by {
  id: order_by
}

"""
Boolean expression to filter rows from the table "group". All fields are combined with a logical 'AND'.
"""
input group_bool_exp {
  _and: [group_bool_exp!]
  _not: group_bool_exp
  _or: [group_bool_exp!]
  app_user: app_user_bool_exp
  creatorId: String_comparison_exp
  group_members: group_member_bool_exp
  id: Int_comparison_exp
  name: String_comparison_exp
}

"""
unique or primary key constraints on table "group"
"""
enum group_constraint {
  """unique or primary key constraint"""
  group_pkey
}

"""
input type for incrementing numeric columns in table "group"
"""
input group_inc_input {
  id: Int
}

"""
input type for inserting data into table "group"
"""
input group_insert_input {
  app_user: app_user_obj_rel_insert_input
  creatorId: String
  group_members: group_member_arr_rel_insert_input
  id: Int
  name: String
}

"""aggregate max on columns"""
type group_max_fields {
  creatorId: String
  id: Int
  name: String
}

"""
order by max() on columns of table "group"
"""
input group_max_order_by {
  creatorId: order_by
  id: order_by
  name: order_by
}

"""
columns and relationships of "group_member"
"""
type group_member {
  """An object relationship"""
  app_user: app_user

  """An object relationship"""
  group: group
  groupId: Int
  memberId: String
  role: String
  updatedAt: timestamp
}

"""
aggregated selection of "group_member"
"""
type group_member_aggregate {
  aggregate: group_member_aggregate_fields
  nodes: [group_member!]!
}

"""
aggregate fields of "group_member"
"""
type group_member_aggregate_fields {
  avg: group_member_avg_fields
  count(columns: [group_member_select_column!], distinct: Boolean): Int!
  max: group_member_max_fields
  min: group_member_min_fields
  stddev: group_member_stddev_fields
  stddev_pop: group_member_stddev_pop_fields
  stddev_samp: group_member_stddev_samp_fields
  sum: group_member_sum_fields
  var_pop: group_member_var_pop_fields
  var_samp: group_member_var_samp_fields
  variance: group_member_variance_fields
}

"""
order by aggregate values of table "group_member"
"""
input group_member_aggregate_order_by {
  avg: group_member_avg_order_by
  count: order_by
  max: group_member_max_order_by
  min: group_member_min_order_by
  stddev: group_member_stddev_order_by
  stddev_pop: group_member_stddev_pop_order_by
  stddev_samp: group_member_stddev_samp_order_by
  sum: group_member_sum_order_by
  var_pop: group_member_var_pop_order_by
  var_samp: group_member_var_samp_order_by
  variance: group_member_variance_order_by
}

"""
input type for inserting array relation for remote table "group_member"
"""
input group_member_arr_rel_insert_input {
  data: [group_member_insert_input!]!
}

"""aggregate avg on columns"""
type group_member_avg_fields {
  groupId: Float
}

"""
order by avg() on columns of table "group_member"
"""
input group_member_avg_order_by {
  groupId: order_by
}

"""
Boolean expression to filter rows from the table "group_member". All fields are combined with a logical 'AND'.
"""
input group_member_bool_exp {
  _and: [group_member_bool_exp!]
  _not: group_member_bool_exp
  _or: [group_member_bool_exp!]
  app_user: app_user_bool_exp
  group: group_bool_exp
  groupId: Int_comparison_exp
  memberId: String_comparison_exp
  role: String_comparison_exp
  updatedAt: timestamp_comparison_exp
}

"""
input type for incrementing numeric columns in table "group_member"
"""
input group_member_inc_input {
  groupId: Int
}

"""
input type for inserting data into table "group_member"
"""
input group_member_insert_input {
  app_user: app_user_obj_rel_insert_input
  group: group_obj_rel_insert_input
  groupId: Int
  memberId: String
  role: String
  updatedAt: timestamp
}

"""aggregate max on columns"""
type group_member_max_fields {
  groupId: Int
  memberId: String
  role: String
  updatedAt: timestamp
}

"""
order by max() on columns of table "group_member"
"""
input group_member_max_order_by {
  groupId: order_by
  memberId: order_by
  role: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type group_member_min_fields {
  groupId: Int
  memberId: String
  role: String
  updatedAt: timestamp
}

"""
order by min() on columns of table "group_member"
"""
input group_member_min_order_by {
  groupId: order_by
  memberId: order_by
  role: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "group_member"
"""
type group_member_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [group_member!]!
}

"""Ordering options when selecting data from "group_member"."""
input group_member_order_by {
  app_user: app_user_order_by
  group: group_order_by
  groupId: order_by
  memberId: order_by
  role: order_by
  updatedAt: order_by
}

"""
select columns of table "group_member"
"""
enum group_member_select_column {
  """column name"""
  groupId

  """column name"""
  memberId

  """column name"""
  role

  """column name"""
  updatedAt
}

"""
input type for updating data in table "group_member"
"""
input group_member_set_input {
  groupId: Int
  memberId: String
  role: String
  updatedAt: timestamp
}

"""aggregate stddev on columns"""
type group_member_stddev_fields {
  groupId: Float
}

"""
order by stddev() on columns of table "group_member"
"""
input group_member_stddev_order_by {
  groupId: order_by
}

"""aggregate stddev_pop on columns"""
type group_member_stddev_pop_fields {
  groupId: Float
}

"""
order by stddev_pop() on columns of table "group_member"
"""
input group_member_stddev_pop_order_by {
  groupId: order_by
}

"""aggregate stddev_samp on columns"""
type group_member_stddev_samp_fields {
  groupId: Float
}

"""
order by stddev_samp() on columns of table "group_member"
"""
input group_member_stddev_samp_order_by {
  groupId: order_by
}

"""aggregate sum on columns"""
type group_member_sum_fields {
  groupId: Int
}

"""
order by sum() on columns of table "group_member"
"""
input group_member_sum_order_by {
  groupId: order_by
}

"""aggregate var_pop on columns"""
type group_member_var_pop_fields {
  groupId: Float
}

"""
order by var_pop() on columns of table "group_member"
"""
input group_member_var_pop_order_by {
  groupId: order_by
}

"""aggregate var_samp on columns"""
type group_member_var_samp_fields {
  groupId: Float
}

"""
order by var_samp() on columns of table "group_member"
"""
input group_member_var_samp_order_by {
  groupId: order_by
}

"""aggregate variance on columns"""
type group_member_variance_fields {
  groupId: Float
}

"""
order by variance() on columns of table "group_member"
"""
input group_member_variance_order_by {
  groupId: order_by
}

"""aggregate min on columns"""
type group_min_fields {
  creatorId: String
  id: Int
  name: String
}

"""
order by min() on columns of table "group"
"""
input group_min_order_by {
  creatorId: order_by
  id: order_by
  name: order_by
}

"""
response of any mutation on the table "group"
"""
type group_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [group!]!
}

"""
input type for inserting object relation for remote table "group"
"""
input group_obj_rel_insert_input {
  data: group_insert_input!

  """upsert condition"""
  on_conflict: group_on_conflict
}

"""
on_conflict condition type for table "group"
"""
input group_on_conflict {
  constraint: group_constraint!
  update_columns: [group_update_column!]! = []
  where: group_bool_exp
}

"""Ordering options when selecting data from "group"."""
input group_order_by {
  app_user: app_user_order_by
  creatorId: order_by
  group_members_aggregate: group_member_aggregate_order_by
  id: order_by
  name: order_by
}

"""primary key columns input for table: group"""
input group_pk_columns_input {
  id: Int!
}

"""
select columns of table "group"
"""
enum group_select_column {
  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  name
}

"""
input type for updating data in table "group"
"""
input group_set_input {
  creatorId: String
  id: Int
  name: String
}

"""aggregate stddev on columns"""
type group_stddev_fields {
  id: Float
}

"""
order by stddev() on columns of table "group"
"""
input group_stddev_order_by {
  id: order_by
}

"""aggregate stddev_pop on columns"""
type group_stddev_pop_fields {
  id: Float
}

"""
order by stddev_pop() on columns of table "group"
"""
input group_stddev_pop_order_by {
  id: order_by
}

"""aggregate stddev_samp on columns"""
type group_stddev_samp_fields {
  id: Float
}

"""
order by stddev_samp() on columns of table "group"
"""
input group_stddev_samp_order_by {
  id: order_by
}

"""aggregate sum on columns"""
type group_sum_fields {
  id: Int
}

"""
order by sum() on columns of table "group"
"""
input group_sum_order_by {
  id: order_by
}

"""
update columns of table "group"
"""
enum group_update_column {
  """column name"""
  creatorId

  """column name"""
  id

  """column name"""
  name
}

"""aggregate var_pop on columns"""
type group_var_pop_fields {
  id: Float
}

"""
order by var_pop() on columns of table "group"
"""
input group_var_pop_order_by {
  id: order_by
}

"""aggregate var_samp on columns"""
type group_var_samp_fields {
  id: Float
}

"""
order by var_samp() on columns of table "group"
"""
input group_var_samp_order_by {
  id: order_by
}

"""aggregate variance on columns"""
type group_variance_fields {
  id: Float
}

"""
order by variance() on columns of table "group"
"""
input group_variance_order_by {
  id: order_by
}

scalar jsonb

"""
Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'.
"""
input jsonb_comparison_exp {
  """is the column contained in the given json value"""
  _contained_in: jsonb

  """does the column contain the given json value at the top level"""
  _contains: jsonb
  _eq: jsonb
  _gt: jsonb
  _gte: jsonb

  """does the string exist as a top-level key in the column"""
  _has_key: String

  """do all of these strings exist as top-level keys in the column"""
  _has_keys_all: [String!]

  """do any of these strings exist as top-level keys in the column"""
  _has_keys_any: [String!]
  _in: [jsonb!]
  _is_null: Boolean
  _lt: jsonb
  _lte: jsonb
  _neq: jsonb
  _nin: [jsonb!]
}

"""mutation root"""
type mutation_root {
  """
  delete single row from the table: "auth.providers"
  """
  deleteAuthProvider(id: String!): authProviders

  """
  delete single row from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequest(id: uuid!): authProviderRequests

  """
  delete data from the table: "auth.provider_requests"
  """
  deleteAuthProviderRequests(
    """filter the rows which have to be deleted"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  delete data from the table: "auth.providers"
  """
  deleteAuthProviders(
    """filter the rows which have to be deleted"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  delete single row from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshToken(refreshToken: uuid!): authRefreshTokens

  """
  delete data from the table: "auth.refresh_tokens"
  """
  deleteAuthRefreshTokens(
    """filter the rows which have to be deleted"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  delete single row from the table: "auth.roles"
  """
  deleteAuthRole(role: String!): authRoles

  """
  delete data from the table: "auth.roles"
  """
  deleteAuthRoles(
    """filter the rows which have to be deleted"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  delete single row from the table: "auth.user_providers"
  """
  deleteAuthUserProvider(id: uuid!): authUserProviders

  """
  delete data from the table: "auth.user_providers"
  """
  deleteAuthUserProviders(
    """filter the rows which have to be deleted"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  delete single row from the table: "auth.user_roles"
  """
  deleteAuthUserRole(id: uuid!): authUserRoles

  """
  delete data from the table: "auth.user_roles"
  """
  deleteAuthUserRoles(
    """filter the rows which have to be deleted"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  delete single row from the table: "storage.buckets"
  """
  deleteBucket(id: String!): buckets

  """
  delete data from the table: "storage.buckets"
  """
  deleteBuckets(
    """filter the rows which have to be deleted"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  delete single row from the table: "storage.files"
  """
  deleteFile(id: uuid!): files

  """
  delete data from the table: "storage.files"
  """
  deleteFiles(
    """filter the rows which have to be deleted"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  delete single row from the table: "auth.users"
  """
  deleteUser(id: uuid!): users

  """
  delete data from the table: "auth.users"
  """
  deleteUsers(
    """filter the rows which have to be deleted"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  delete data from the table: "app_user"
  """
  delete_app_user(
    """filter the rows which have to be deleted"""
    where: app_user_bool_exp!
  ): app_user_mutation_response

  """
  delete single row from the table: "app_user"
  """
  delete_app_user_by_pk(id: String!): app_user

  """
  delete data from the table: "chatroom"
  """
  delete_chatroom(
    """filter the rows which have to be deleted"""
    where: chatroom_bool_exp!
  ): chatroom_mutation_response

  """
  delete single row from the table: "chatroom"
  """
  delete_chatroom_by_pk(id: Int!): chatroom

  """
  delete data from the table: "chatroom_message"
  """
  delete_chatroom_message(
    """filter the rows which have to be deleted"""
    where: chatroom_message_bool_exp!
  ): chatroom_message_mutation_response

  """
  delete single row from the table: "chatroom_message"
  """
  delete_chatroom_message_by_pk(id: Int!): chatroom_message

  """
  delete data from the table: "clothing"
  """
  delete_clothing(
    """filter the rows which have to be deleted"""
    where: clothing_bool_exp!
  ): clothing_mutation_response

  """
  delete single row from the table: "clothing"
  """
  delete_clothing_by_pk(id: Int!): clothing

  """
  delete data from the table: "clothing_status"
  """
  delete_clothing_status(
    """filter the rows which have to be deleted"""
    where: clothing_status_bool_exp!
  ): clothing_status_mutation_response

  """
  delete data from the table: "group"
  """
  delete_group(
    """filter the rows which have to be deleted"""
    where: group_bool_exp!
  ): group_mutation_response

  """
  delete single row from the table: "group"
  """
  delete_group_by_pk(id: Int!): group

  """
  delete data from the table: "group_member"
  """
  delete_group_member(
    """filter the rows which have to be deleted"""
    where: group_member_bool_exp!
  ): group_member_mutation_response

  """
  delete data from the table: "rating"
  """
  delete_rating(
    """filter the rows which have to be deleted"""
    where: rating_bool_exp!
  ): rating_mutation_response

  """
  delete data from the table: "user_avatar"
  """
  delete_user_avatar(
    """filter the rows which have to be deleted"""
    where: user_avatar_bool_exp!
  ): user_avatar_mutation_response

  """
  delete data from the table: "user_following"
  """
  delete_user_following(
    """filter the rows which have to be deleted"""
    where: user_following_bool_exp!
  ): user_following_mutation_response

  """
  delete data from the table: "user_wardrobe"
  """
  delete_user_wardrobe(
    """filter the rows which have to be deleted"""
    where: user_wardrobe_bool_exp!
  ): user_wardrobe_mutation_response

  """
  delete data from the table: "user_wishlist"
  """
  delete_user_wishlist(
    """filter the rows which have to be deleted"""
    where: user_wishlist_bool_exp!
  ): user_wishlist_mutation_response

  """
  insert a single row into the table: "auth.providers"
  """
  insertAuthProvider(
    """the row to be inserted"""
    object: authProviders_insert_input!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders

  """
  insert a single row into the table: "auth.provider_requests"
  """
  insertAuthProviderRequest(
    """the row to be inserted"""
    object: authProviderRequests_insert_input!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests

  """
  insert data into the table: "auth.provider_requests"
  """
  insertAuthProviderRequests(
    """the rows to be inserted"""
    objects: [authProviderRequests_insert_input!]!

    """upsert condition"""
    on_conflict: authProviderRequests_on_conflict
  ): authProviderRequests_mutation_response

  """
  insert data into the table: "auth.providers"
  """
  insertAuthProviders(
    """the rows to be inserted"""
    objects: [authProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authProviders_on_conflict
  ): authProviders_mutation_response

  """
  insert a single row into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshToken(
    """the row to be inserted"""
    object: authRefreshTokens_insert_input!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens

  """
  insert data into the table: "auth.refresh_tokens"
  """
  insertAuthRefreshTokens(
    """the rows to be inserted"""
    objects: [authRefreshTokens_insert_input!]!

    """upsert condition"""
    on_conflict: authRefreshTokens_on_conflict
  ): authRefreshTokens_mutation_response

  """
  insert a single row into the table: "auth.roles"
  """
  insertAuthRole(
    """the row to be inserted"""
    object: authRoles_insert_input!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles

  """
  insert data into the table: "auth.roles"
  """
  insertAuthRoles(
    """the rows to be inserted"""
    objects: [authRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authRoles_on_conflict
  ): authRoles_mutation_response

  """
  insert a single row into the table: "auth.user_providers"
  """
  insertAuthUserProvider(
    """the row to be inserted"""
    object: authUserProviders_insert_input!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders

  """
  insert data into the table: "auth.user_providers"
  """
  insertAuthUserProviders(
    """the rows to be inserted"""
    objects: [authUserProviders_insert_input!]!

    """upsert condition"""
    on_conflict: authUserProviders_on_conflict
  ): authUserProviders_mutation_response

  """
  insert a single row into the table: "auth.user_roles"
  """
  insertAuthUserRole(
    """the row to be inserted"""
    object: authUserRoles_insert_input!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles

  """
  insert data into the table: "auth.user_roles"
  """
  insertAuthUserRoles(
    """the rows to be inserted"""
    objects: [authUserRoles_insert_input!]!

    """upsert condition"""
    on_conflict: authUserRoles_on_conflict
  ): authUserRoles_mutation_response

  """
  insert a single row into the table: "storage.buckets"
  """
  insertBucket(
    """the row to be inserted"""
    object: buckets_insert_input!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets

  """
  insert data into the table: "storage.buckets"
  """
  insertBuckets(
    """the rows to be inserted"""
    objects: [buckets_insert_input!]!

    """upsert condition"""
    on_conflict: buckets_on_conflict
  ): buckets_mutation_response

  """
  insert a single row into the table: "storage.files"
  """
  insertFile(
    """the row to be inserted"""
    object: files_insert_input!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files

  """
  insert data into the table: "storage.files"
  """
  insertFiles(
    """the rows to be inserted"""
    objects: [files_insert_input!]!

    """upsert condition"""
    on_conflict: files_on_conflict
  ): files_mutation_response

  """
  insert a single row into the table: "auth.users"
  """
  insertUser(
    """the row to be inserted"""
    object: users_insert_input!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users

  """
  insert data into the table: "auth.users"
  """
  insertUsers(
    """the rows to be inserted"""
    objects: [users_insert_input!]!

    """upsert condition"""
    on_conflict: users_on_conflict
  ): users_mutation_response

  """
  insert data into the table: "app_user"
  """
  insert_app_user(
    """the rows to be inserted"""
    objects: [app_user_insert_input!]!

    """upsert condition"""
    on_conflict: app_user_on_conflict
  ): app_user_mutation_response

  """
  insert a single row into the table: "app_user"
  """
  insert_app_user_one(
    """the row to be inserted"""
    object: app_user_insert_input!

    """upsert condition"""
    on_conflict: app_user_on_conflict
  ): app_user

  """
  insert data into the table: "chatroom"
  """
  insert_chatroom(
    """the rows to be inserted"""
    objects: [chatroom_insert_input!]!

    """upsert condition"""
    on_conflict: chatroom_on_conflict
  ): chatroom_mutation_response

  """
  insert data into the table: "chatroom_message"
  """
  insert_chatroom_message(
    """the rows to be inserted"""
    objects: [chatroom_message_insert_input!]!

    """upsert condition"""
    on_conflict: chatroom_message_on_conflict
  ): chatroom_message_mutation_response

  """
  insert a single row into the table: "chatroom_message"
  """
  insert_chatroom_message_one(
    """the row to be inserted"""
    object: chatroom_message_insert_input!

    """upsert condition"""
    on_conflict: chatroom_message_on_conflict
  ): chatroom_message

  """
  insert a single row into the table: "chatroom"
  """
  insert_chatroom_one(
    """the row to be inserted"""
    object: chatroom_insert_input!

    """upsert condition"""
    on_conflict: chatroom_on_conflict
  ): chatroom

  """
  insert data into the table: "clothing"
  """
  insert_clothing(
    """the rows to be inserted"""
    objects: [clothing_insert_input!]!

    """upsert condition"""
    on_conflict: clothing_on_conflict
  ): clothing_mutation_response

  """
  insert a single row into the table: "clothing"
  """
  insert_clothing_one(
    """the row to be inserted"""
    object: clothing_insert_input!

    """upsert condition"""
    on_conflict: clothing_on_conflict
  ): clothing

  """
  insert data into the table: "clothing_status"
  """
  insert_clothing_status(
    """the rows to be inserted"""
    objects: [clothing_status_insert_input!]!
  ): clothing_status_mutation_response

  """
  insert a single row into the table: "clothing_status"
  """
  insert_clothing_status_one(
    """the row to be inserted"""
    object: clothing_status_insert_input!
  ): clothing_status

  """
  insert data into the table: "group"
  """
  insert_group(
    """the rows to be inserted"""
    objects: [group_insert_input!]!

    """upsert condition"""
    on_conflict: group_on_conflict
  ): group_mutation_response

  """
  insert data into the table: "group_member"
  """
  insert_group_member(
    """the rows to be inserted"""
    objects: [group_member_insert_input!]!
  ): group_member_mutation_response

  """
  insert a single row into the table: "group_member"
  """
  insert_group_member_one(
    """the row to be inserted"""
    object: group_member_insert_input!
  ): group_member

  """
  insert a single row into the table: "group"
  """
  insert_group_one(
    """the row to be inserted"""
    object: group_insert_input!

    """upsert condition"""
    on_conflict: group_on_conflict
  ): group

  """
  insert data into the table: "rating"
  """
  insert_rating(
    """the rows to be inserted"""
    objects: [rating_insert_input!]!
  ): rating_mutation_response

  """
  insert a single row into the table: "rating"
  """
  insert_rating_one(
    """the row to be inserted"""
    object: rating_insert_input!
  ): rating

  """
  insert data into the table: "user_avatar"
  """
  insert_user_avatar(
    """the rows to be inserted"""
    objects: [user_avatar_insert_input!]!
  ): user_avatar_mutation_response

  """
  insert a single row into the table: "user_avatar"
  """
  insert_user_avatar_one(
    """the row to be inserted"""
    object: user_avatar_insert_input!
  ): user_avatar

  """
  insert data into the table: "user_following"
  """
  insert_user_following(
    """the rows to be inserted"""
    objects: [user_following_insert_input!]!
  ): user_following_mutation_response

  """
  insert a single row into the table: "user_following"
  """
  insert_user_following_one(
    """the row to be inserted"""
    object: user_following_insert_input!
  ): user_following

  """
  insert data into the table: "user_wardrobe"
  """
  insert_user_wardrobe(
    """the rows to be inserted"""
    objects: [user_wardrobe_insert_input!]!
  ): user_wardrobe_mutation_response

  """
  insert a single row into the table: "user_wardrobe"
  """
  insert_user_wardrobe_one(
    """the row to be inserted"""
    object: user_wardrobe_insert_input!
  ): user_wardrobe

  """
  insert data into the table: "user_wishlist"
  """
  insert_user_wishlist(
    """the rows to be inserted"""
    objects: [user_wishlist_insert_input!]!
  ): user_wishlist_mutation_response

  """
  insert a single row into the table: "user_wishlist"
  """
  insert_user_wishlist_one(
    """the row to be inserted"""
    object: user_wishlist_insert_input!
  ): user_wishlist

  """
  update single row of the table: "auth.providers"
  """
  updateAuthProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input
    pk_columns: authProviders_pk_columns_input!
  ): authProviders

  """
  update single row of the table: "auth.provider_requests"
  """
  updateAuthProviderRequest(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input
    pk_columns: authProviderRequests_pk_columns_input!
  ): authProviderRequests

  """
  update data of the table: "auth.provider_requests"
  """
  updateAuthProviderRequests(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviderRequests_set_input

    """filter the rows which have to be updated"""
    where: authProviderRequests_bool_exp!
  ): authProviderRequests_mutation_response

  """
  update data of the table: "auth.providers"
  """
  updateAuthProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authProviders_set_input

    """filter the rows which have to be updated"""
    where: authProviders_bool_exp!
  ): authProviders_mutation_response

  """
  update single row of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshToken(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input
    pk_columns: authRefreshTokens_pk_columns_input!
  ): authRefreshTokens

  """
  update data of the table: "auth.refresh_tokens"
  """
  updateAuthRefreshTokens(
    """sets the columns of the filtered rows to the given values"""
    _set: authRefreshTokens_set_input

    """filter the rows which have to be updated"""
    where: authRefreshTokens_bool_exp!
  ): authRefreshTokens_mutation_response

  """
  update single row of the table: "auth.roles"
  """
  updateAuthRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input
    pk_columns: authRoles_pk_columns_input!
  ): authRoles

  """
  update data of the table: "auth.roles"
  """
  updateAuthRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authRoles_set_input

    """filter the rows which have to be updated"""
    where: authRoles_bool_exp!
  ): authRoles_mutation_response

  """
  update single row of the table: "auth.user_providers"
  """
  updateAuthUserProvider(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input
    pk_columns: authUserProviders_pk_columns_input!
  ): authUserProviders

  """
  update data of the table: "auth.user_providers"
  """
  updateAuthUserProviders(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserProviders_set_input

    """filter the rows which have to be updated"""
    where: authUserProviders_bool_exp!
  ): authUserProviders_mutation_response

  """
  update single row of the table: "auth.user_roles"
  """
  updateAuthUserRole(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input
    pk_columns: authUserRoles_pk_columns_input!
  ): authUserRoles

  """
  update data of the table: "auth.user_roles"
  """
  updateAuthUserRoles(
    """sets the columns of the filtered rows to the given values"""
    _set: authUserRoles_set_input

    """filter the rows which have to be updated"""
    where: authUserRoles_bool_exp!
  ): authUserRoles_mutation_response

  """
  update single row of the table: "storage.buckets"
  """
  updateBucket(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input
    pk_columns: buckets_pk_columns_input!
  ): buckets

  """
  update data of the table: "storage.buckets"
  """
  updateBuckets(
    """increments the numeric columns with given value of the filtered values"""
    _inc: buckets_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: buckets_set_input

    """filter the rows which have to be updated"""
    where: buckets_bool_exp!
  ): buckets_mutation_response

  """
  update single row of the table: "storage.files"
  """
  updateFile(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input
    pk_columns: files_pk_columns_input!
  ): files

  """
  update data of the table: "storage.files"
  """
  updateFiles(
    """increments the numeric columns with given value of the filtered values"""
    _inc: files_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: files_set_input

    """filter the rows which have to be updated"""
    where: files_bool_exp!
  ): files_mutation_response

  """
  update single row of the table: "auth.users"
  """
  updateUser(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users

  """
  update data of the table: "auth.users"
  """
  updateUsers(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: users_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: users_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: users_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: users_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: users_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: users_set_input

    """filter the rows which have to be updated"""
    where: users_bool_exp!
  ): users_mutation_response

  """
  update data of the table: "app_user"
  """
  update_app_user(
    """sets the columns of the filtered rows to the given values"""
    _set: app_user_set_input

    """filter the rows which have to be updated"""
    where: app_user_bool_exp!
  ): app_user_mutation_response

  """
  update single row of the table: "app_user"
  """
  update_app_user_by_pk(
    """sets the columns of the filtered rows to the given values"""
    _set: app_user_set_input
    pk_columns: app_user_pk_columns_input!
  ): app_user

  """
  update data of the table: "chatroom"
  """
  update_chatroom(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chatroom_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chatroom_set_input

    """filter the rows which have to be updated"""
    where: chatroom_bool_exp!
  ): chatroom_mutation_response

  """
  update single row of the table: "chatroom"
  """
  update_chatroom_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chatroom_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chatroom_set_input
    pk_columns: chatroom_pk_columns_input!
  ): chatroom

  """
  update data of the table: "chatroom_message"
  """
  update_chatroom_message(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chatroom_message_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chatroom_message_set_input

    """filter the rows which have to be updated"""
    where: chatroom_message_bool_exp!
  ): chatroom_message_mutation_response

  """
  update single row of the table: "chatroom_message"
  """
  update_chatroom_message_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: chatroom_message_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: chatroom_message_set_input
    pk_columns: chatroom_message_pk_columns_input!
  ): chatroom_message

  """
  update data of the table: "clothing"
  """
  update_clothing(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: clothing_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: clothing_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: clothing_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: clothing_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: clothing_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: clothing_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: clothing_set_input

    """filter the rows which have to be updated"""
    where: clothing_bool_exp!
  ): clothing_mutation_response

  """
  update single row of the table: "clothing"
  """
  update_clothing_by_pk(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: clothing_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: clothing_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: clothing_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: clothing_delete_key_input

    """increments the numeric columns with given value of the filtered values"""
    _inc: clothing_inc_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: clothing_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: clothing_set_input
    pk_columns: clothing_pk_columns_input!
  ): clothing

  """
  update data of the table: "clothing_status"
  """
  update_clothing_status(
    """increments the numeric columns with given value of the filtered values"""
    _inc: clothing_status_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: clothing_status_set_input

    """filter the rows which have to be updated"""
    where: clothing_status_bool_exp!
  ): clothing_status_mutation_response

  """
  update data of the table: "group"
  """
  update_group(
    """increments the numeric columns with given value of the filtered values"""
    _inc: group_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: group_set_input

    """filter the rows which have to be updated"""
    where: group_bool_exp!
  ): group_mutation_response

  """
  update single row of the table: "group"
  """
  update_group_by_pk(
    """increments the numeric columns with given value of the filtered values"""
    _inc: group_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: group_set_input
    pk_columns: group_pk_columns_input!
  ): group

  """
  update data of the table: "group_member"
  """
  update_group_member(
    """increments the numeric columns with given value of the filtered values"""
    _inc: group_member_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: group_member_set_input

    """filter the rows which have to be updated"""
    where: group_member_bool_exp!
  ): group_member_mutation_response

  """
  update data of the table: "rating"
  """
  update_rating(
    """increments the numeric columns with given value of the filtered values"""
    _inc: rating_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: rating_set_input

    """filter the rows which have to be updated"""
    where: rating_bool_exp!
  ): rating_mutation_response

  """
  update data of the table: "user_avatar"
  """
  update_user_avatar(
    """append existing jsonb value of filtered columns with new jsonb value"""
    _append: user_avatar_append_input

    """
    delete the field or element with specified path (for JSON arrays, negative integers count from the end)
    """
    _delete_at_path: user_avatar_delete_at_path_input

    """
    delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
    """
    _delete_elem: user_avatar_delete_elem_input

    """
    delete key/value pair or string element. key/value pairs are matched based on their key value
    """
    _delete_key: user_avatar_delete_key_input

    """prepend existing jsonb value of filtered columns with new jsonb value"""
    _prepend: user_avatar_prepend_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_avatar_set_input

    """filter the rows which have to be updated"""
    where: user_avatar_bool_exp!
  ): user_avatar_mutation_response

  """
  update data of the table: "user_following"
  """
  update_user_following(
    """sets the columns of the filtered rows to the given values"""
    _set: user_following_set_input

    """filter the rows which have to be updated"""
    where: user_following_bool_exp!
  ): user_following_mutation_response

  """
  update data of the table: "user_wardrobe"
  """
  update_user_wardrobe(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_wardrobe_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_wardrobe_set_input

    """filter the rows which have to be updated"""
    where: user_wardrobe_bool_exp!
  ): user_wardrobe_mutation_response

  """
  update data of the table: "user_wishlist"
  """
  update_user_wishlist(
    """increments the numeric columns with given value of the filtered values"""
    _inc: user_wishlist_inc_input

    """sets the columns of the filtered rows to the given values"""
    _set: user_wishlist_set_input

    """filter the rows which have to be updated"""
    where: user_wishlist_bool_exp!
  ): user_wishlist_mutation_response
}

"""column ordering options"""
enum order_by {
  """in ascending order, nulls last"""
  asc

  """in ascending order, nulls first"""
  asc_nulls_first

  """in ascending order, nulls last"""
  asc_nulls_last

  """in descending order, nulls first"""
  desc

  """in descending order, nulls first"""
  desc_nulls_first

  """in descending order, nulls last"""
  desc_nulls_last
}

type query_root {
  """
  fetch data from the table: "app_user"
  """
  app_user(
    """distinct select on columns"""
    distinct_on: [app_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_user_order_by!]

    """filter the rows returned"""
    where: app_user_bool_exp
  ): [app_user!]!

  """
  fetch aggregated fields from the table: "app_user"
  """
  app_user_aggregate(
    """distinct select on columns"""
    distinct_on: [app_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_user_order_by!]

    """filter the rows returned"""
    where: app_user_bool_exp
  ): app_user_aggregate!

  """fetch data from the table: "app_user" using primary key columns"""
  app_user_by_pk(id: String!): app_user

  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(refreshToken: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table: "chatroom"
  """
  chatroom(
    """distinct select on columns"""
    distinct_on: [chatroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_order_by!]

    """filter the rows returned"""
    where: chatroom_bool_exp
  ): [chatroom!]!

  """
  fetch aggregated fields from the table: "chatroom"
  """
  chatroom_aggregate(
    """distinct select on columns"""
    distinct_on: [chatroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_order_by!]

    """filter the rows returned"""
    where: chatroom_bool_exp
  ): chatroom_aggregate!

  """fetch data from the table: "chatroom" using primary key columns"""
  chatroom_by_pk(id: Int!): chatroom

  """
  fetch data from the table: "chatroom_message"
  """
  chatroom_message(
    """distinct select on columns"""
    distinct_on: [chatroom_message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_message_order_by!]

    """filter the rows returned"""
    where: chatroom_message_bool_exp
  ): [chatroom_message!]!

  """
  fetch aggregated fields from the table: "chatroom_message"
  """
  chatroom_message_aggregate(
    """distinct select on columns"""
    distinct_on: [chatroom_message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_message_order_by!]

    """filter the rows returned"""
    where: chatroom_message_bool_exp
  ): chatroom_message_aggregate!

  """
  fetch data from the table: "chatroom_message" using primary key columns
  """
  chatroom_message_by_pk(id: Int!): chatroom_message

  """
  fetch data from the table: "clothing"
  """
  clothing(
    """distinct select on columns"""
    distinct_on: [clothing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_order_by!]

    """filter the rows returned"""
    where: clothing_bool_exp
  ): [clothing!]!

  """
  fetch aggregated fields from the table: "clothing"
  """
  clothing_aggregate(
    """distinct select on columns"""
    distinct_on: [clothing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_order_by!]

    """filter the rows returned"""
    where: clothing_bool_exp
  ): clothing_aggregate!

  """fetch data from the table: "clothing" using primary key columns"""
  clothing_by_pk(id: Int!): clothing

  """
  fetch data from the table: "clothing_status"
  """
  clothing_status(
    """distinct select on columns"""
    distinct_on: [clothing_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_status_order_by!]

    """filter the rows returned"""
    where: clothing_status_bool_exp
  ): [clothing_status!]!

  """
  fetch aggregated fields from the table: "clothing_status"
  """
  clothing_status_aggregate(
    """distinct select on columns"""
    distinct_on: [clothing_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_status_order_by!]

    """filter the rows returned"""
    where: clothing_status_bool_exp
  ): clothing_status_aggregate!

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """
  fetch data from the table: "storage.files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """
  fetch data from the table: "group"
  """
  group(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): [group!]!

  """
  fetch aggregated fields from the table: "group"
  """
  group_aggregate(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): group_aggregate!

  """fetch data from the table: "group" using primary key columns"""
  group_by_pk(id: Int!): group

  """
  fetch data from the table: "group_member"
  """
  group_member(
    """distinct select on columns"""
    distinct_on: [group_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_member_order_by!]

    """filter the rows returned"""
    where: group_member_bool_exp
  ): [group_member!]!

  """
  fetch aggregated fields from the table: "group_member"
  """
  group_member_aggregate(
    """distinct select on columns"""
    distinct_on: [group_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_member_order_by!]

    """filter the rows returned"""
    where: group_member_bool_exp
  ): group_member_aggregate!

  """
  fetch data from the table: "rating"
  """
  rating(
    """distinct select on columns"""
    distinct_on: [rating_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rating_order_by!]

    """filter the rows returned"""
    where: rating_bool_exp
  ): [rating!]!

  """
  fetch aggregated fields from the table: "rating"
  """
  rating_aggregate(
    """distinct select on columns"""
    distinct_on: [rating_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rating_order_by!]

    """filter the rows returned"""
    where: rating_bool_exp
  ): rating_aggregate!

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch aggregated fields from the table: "auth.users"
  """
  userAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table: "user_avatar"
  """
  user_avatar(
    """distinct select on columns"""
    distinct_on: [user_avatar_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_avatar_order_by!]

    """filter the rows returned"""
    where: user_avatar_bool_exp
  ): [user_avatar!]!

  """
  fetch aggregated fields from the table: "user_avatar"
  """
  user_avatar_aggregate(
    """distinct select on columns"""
    distinct_on: [user_avatar_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_avatar_order_by!]

    """filter the rows returned"""
    where: user_avatar_bool_exp
  ): user_avatar_aggregate!

  """
  fetch data from the table: "user_following"
  """
  user_following(
    """distinct select on columns"""
    distinct_on: [user_following_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_following_order_by!]

    """filter the rows returned"""
    where: user_following_bool_exp
  ): [user_following!]!

  """
  fetch aggregated fields from the table: "user_following"
  """
  user_following_aggregate(
    """distinct select on columns"""
    distinct_on: [user_following_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_following_order_by!]

    """filter the rows returned"""
    where: user_following_bool_exp
  ): user_following_aggregate!

  """
  fetch data from the table: "user_wardrobe"
  """
  user_wardrobe(
    """distinct select on columns"""
    distinct_on: [user_wardrobe_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wardrobe_order_by!]

    """filter the rows returned"""
    where: user_wardrobe_bool_exp
  ): [user_wardrobe!]!

  """
  fetch aggregated fields from the table: "user_wardrobe"
  """
  user_wardrobe_aggregate(
    """distinct select on columns"""
    distinct_on: [user_wardrobe_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wardrobe_order_by!]

    """filter the rows returned"""
    where: user_wardrobe_bool_exp
  ): user_wardrobe_aggregate!

  """
  fetch data from the table: "user_wishlist"
  """
  user_wishlist(
    """distinct select on columns"""
    distinct_on: [user_wishlist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wishlist_order_by!]

    """filter the rows returned"""
    where: user_wishlist_bool_exp
  ): [user_wishlist!]!

  """
  fetch aggregated fields from the table: "user_wishlist"
  """
  user_wishlist_aggregate(
    """distinct select on columns"""
    distinct_on: [user_wishlist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wishlist_order_by!]

    """filter the rows returned"""
    where: user_wishlist_bool_exp
  ): user_wishlist_aggregate!

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!
}

"""
columns and relationships of "rating"
"""
type rating {
  """An object relationship"""
  clothing: clothing
  clothingId: Int
  commentOnClothing: String
  commentOnUser: String
  createdAt: timestamp
  star: Int
  title: String
}

"""
aggregated selection of "rating"
"""
type rating_aggregate {
  aggregate: rating_aggregate_fields
  nodes: [rating!]!
}

"""
aggregate fields of "rating"
"""
type rating_aggregate_fields {
  avg: rating_avg_fields
  count(columns: [rating_select_column!], distinct: Boolean): Int!
  max: rating_max_fields
  min: rating_min_fields
  stddev: rating_stddev_fields
  stddev_pop: rating_stddev_pop_fields
  stddev_samp: rating_stddev_samp_fields
  sum: rating_sum_fields
  var_pop: rating_var_pop_fields
  var_samp: rating_var_samp_fields
  variance: rating_variance_fields
}

"""
order by aggregate values of table "rating"
"""
input rating_aggregate_order_by {
  avg: rating_avg_order_by
  count: order_by
  max: rating_max_order_by
  min: rating_min_order_by
  stddev: rating_stddev_order_by
  stddev_pop: rating_stddev_pop_order_by
  stddev_samp: rating_stddev_samp_order_by
  sum: rating_sum_order_by
  var_pop: rating_var_pop_order_by
  var_samp: rating_var_samp_order_by
  variance: rating_variance_order_by
}

"""
input type for inserting array relation for remote table "rating"
"""
input rating_arr_rel_insert_input {
  data: [rating_insert_input!]!
}

"""aggregate avg on columns"""
type rating_avg_fields {
  clothingId: Float
  star: Float
}

"""
order by avg() on columns of table "rating"
"""
input rating_avg_order_by {
  clothingId: order_by
  star: order_by
}

"""
Boolean expression to filter rows from the table "rating". All fields are combined with a logical 'AND'.
"""
input rating_bool_exp {
  _and: [rating_bool_exp!]
  _not: rating_bool_exp
  _or: [rating_bool_exp!]
  clothing: clothing_bool_exp
  clothingId: Int_comparison_exp
  commentOnClothing: String_comparison_exp
  commentOnUser: String_comparison_exp
  createdAt: timestamp_comparison_exp
  star: Int_comparison_exp
  title: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "rating"
"""
input rating_inc_input {
  clothingId: Int
  star: Int
}

"""
input type for inserting data into table "rating"
"""
input rating_insert_input {
  clothing: clothing_obj_rel_insert_input
  clothingId: Int
  commentOnClothing: String
  commentOnUser: String
  createdAt: timestamp
  star: Int
  title: String
}

"""aggregate max on columns"""
type rating_max_fields {
  clothingId: Int
  commentOnClothing: String
  commentOnUser: String
  createdAt: timestamp
  star: Int
  title: String
}

"""
order by max() on columns of table "rating"
"""
input rating_max_order_by {
  clothingId: order_by
  commentOnClothing: order_by
  commentOnUser: order_by
  createdAt: order_by
  star: order_by
  title: order_by
}

"""aggregate min on columns"""
type rating_min_fields {
  clothingId: Int
  commentOnClothing: String
  commentOnUser: String
  createdAt: timestamp
  star: Int
  title: String
}

"""
order by min() on columns of table "rating"
"""
input rating_min_order_by {
  clothingId: order_by
  commentOnClothing: order_by
  commentOnUser: order_by
  createdAt: order_by
  star: order_by
  title: order_by
}

"""
response of any mutation on the table "rating"
"""
type rating_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [rating!]!
}

"""Ordering options when selecting data from "rating"."""
input rating_order_by {
  clothing: clothing_order_by
  clothingId: order_by
  commentOnClothing: order_by
  commentOnUser: order_by
  createdAt: order_by
  star: order_by
  title: order_by
}

"""
select columns of table "rating"
"""
enum rating_select_column {
  """column name"""
  clothingId

  """column name"""
  commentOnClothing

  """column name"""
  commentOnUser

  """column name"""
  createdAt

  """column name"""
  star

  """column name"""
  title
}

"""
input type for updating data in table "rating"
"""
input rating_set_input {
  clothingId: Int
  commentOnClothing: String
  commentOnUser: String
  createdAt: timestamp
  star: Int
  title: String
}

"""aggregate stddev on columns"""
type rating_stddev_fields {
  clothingId: Float
  star: Float
}

"""
order by stddev() on columns of table "rating"
"""
input rating_stddev_order_by {
  clothingId: order_by
  star: order_by
}

"""aggregate stddev_pop on columns"""
type rating_stddev_pop_fields {
  clothingId: Float
  star: Float
}

"""
order by stddev_pop() on columns of table "rating"
"""
input rating_stddev_pop_order_by {
  clothingId: order_by
  star: order_by
}

"""aggregate stddev_samp on columns"""
type rating_stddev_samp_fields {
  clothingId: Float
  star: Float
}

"""
order by stddev_samp() on columns of table "rating"
"""
input rating_stddev_samp_order_by {
  clothingId: order_by
  star: order_by
}

"""aggregate sum on columns"""
type rating_sum_fields {
  clothingId: Int
  star: Int
}

"""
order by sum() on columns of table "rating"
"""
input rating_sum_order_by {
  clothingId: order_by
  star: order_by
}

"""aggregate var_pop on columns"""
type rating_var_pop_fields {
  clothingId: Float
  star: Float
}

"""
order by var_pop() on columns of table "rating"
"""
input rating_var_pop_order_by {
  clothingId: order_by
  star: order_by
}

"""aggregate var_samp on columns"""
type rating_var_samp_fields {
  clothingId: Float
  star: Float
}

"""
order by var_samp() on columns of table "rating"
"""
input rating_var_samp_order_by {
  clothingId: order_by
  star: order_by
}

"""aggregate variance on columns"""
type rating_variance_fields {
  clothingId: Float
  star: Float
}

"""
order by variance() on columns of table "rating"
"""
input rating_variance_order_by {
  clothingId: order_by
  star: order_by
}

type subscription_root {
  """
  fetch data from the table: "app_user"
  """
  app_user(
    """distinct select on columns"""
    distinct_on: [app_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_user_order_by!]

    """filter the rows returned"""
    where: app_user_bool_exp
  ): [app_user!]!

  """
  fetch aggregated fields from the table: "app_user"
  """
  app_user_aggregate(
    """distinct select on columns"""
    distinct_on: [app_user_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [app_user_order_by!]

    """filter the rows returned"""
    where: app_user_bool_exp
  ): app_user_aggregate!

  """fetch data from the table: "app_user" using primary key columns"""
  app_user_by_pk(id: String!): app_user

  """fetch data from the table: "auth.providers" using primary key columns"""
  authProvider(id: String!): authProviders

  """
  fetch data from the table: "auth.provider_requests" using primary key columns
  """
  authProviderRequest(id: uuid!): authProviderRequests

  """
  fetch data from the table: "auth.provider_requests"
  """
  authProviderRequests(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): [authProviderRequests!]!

  """
  fetch aggregated fields from the table: "auth.provider_requests"
  """
  authProviderRequestsAggregate(
    """distinct select on columns"""
    distinct_on: [authProviderRequests_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviderRequests_order_by!]

    """filter the rows returned"""
    where: authProviderRequests_bool_exp
  ): authProviderRequests_aggregate!

  """
  fetch data from the table: "auth.providers"
  """
  authProviders(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): [authProviders!]!

  """
  fetch aggregated fields from the table: "auth.providers"
  """
  authProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authProviders_order_by!]

    """filter the rows returned"""
    where: authProviders_bool_exp
  ): authProviders_aggregate!

  """
  fetch data from the table: "auth.refresh_tokens" using primary key columns
  """
  authRefreshToken(refreshToken: uuid!): authRefreshTokens

  """
  fetch data from the table: "auth.refresh_tokens"
  """
  authRefreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """
  fetch aggregated fields from the table: "auth.refresh_tokens"
  """
  authRefreshTokensAggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """fetch data from the table: "auth.roles" using primary key columns"""
  authRole(role: String!): authRoles

  """
  fetch data from the table: "auth.roles"
  """
  authRoles(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): [authRoles!]!

  """
  fetch aggregated fields from the table: "auth.roles"
  """
  authRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRoles_order_by!]

    """filter the rows returned"""
    where: authRoles_bool_exp
  ): authRoles_aggregate!

  """
  fetch data from the table: "auth.user_providers" using primary key columns
  """
  authUserProvider(id: uuid!): authUserProviders

  """
  fetch data from the table: "auth.user_providers"
  """
  authUserProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """
  fetch aggregated fields from the table: "auth.user_providers"
  """
  authUserProvidersAggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!

  """fetch data from the table: "auth.user_roles" using primary key columns"""
  authUserRole(id: uuid!): authUserRoles

  """
  fetch data from the table: "auth.user_roles"
  """
  authUserRoles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """
  fetch aggregated fields from the table: "auth.user_roles"
  """
  authUserRolesAggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!

  """fetch data from the table: "storage.buckets" using primary key columns"""
  bucket(id: String!): buckets

  """
  fetch data from the table: "storage.buckets"
  """
  buckets(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): [buckets!]!

  """
  fetch aggregated fields from the table: "storage.buckets"
  """
  bucketsAggregate(
    """distinct select on columns"""
    distinct_on: [buckets_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [buckets_order_by!]

    """filter the rows returned"""
    where: buckets_bool_exp
  ): buckets_aggregate!

  """
  fetch data from the table: "chatroom"
  """
  chatroom(
    """distinct select on columns"""
    distinct_on: [chatroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_order_by!]

    """filter the rows returned"""
    where: chatroom_bool_exp
  ): [chatroom!]!

  """
  fetch aggregated fields from the table: "chatroom"
  """
  chatroom_aggregate(
    """distinct select on columns"""
    distinct_on: [chatroom_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_order_by!]

    """filter the rows returned"""
    where: chatroom_bool_exp
  ): chatroom_aggregate!

  """fetch data from the table: "chatroom" using primary key columns"""
  chatroom_by_pk(id: Int!): chatroom

  """
  fetch data from the table: "chatroom_message"
  """
  chatroom_message(
    """distinct select on columns"""
    distinct_on: [chatroom_message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_message_order_by!]

    """filter the rows returned"""
    where: chatroom_message_bool_exp
  ): [chatroom_message!]!

  """
  fetch aggregated fields from the table: "chatroom_message"
  """
  chatroom_message_aggregate(
    """distinct select on columns"""
    distinct_on: [chatroom_message_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [chatroom_message_order_by!]

    """filter the rows returned"""
    where: chatroom_message_bool_exp
  ): chatroom_message_aggregate!

  """
  fetch data from the table: "chatroom_message" using primary key columns
  """
  chatroom_message_by_pk(id: Int!): chatroom_message

  """
  fetch data from the table: "clothing"
  """
  clothing(
    """distinct select on columns"""
    distinct_on: [clothing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_order_by!]

    """filter the rows returned"""
    where: clothing_bool_exp
  ): [clothing!]!

  """
  fetch aggregated fields from the table: "clothing"
  """
  clothing_aggregate(
    """distinct select on columns"""
    distinct_on: [clothing_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_order_by!]

    """filter the rows returned"""
    where: clothing_bool_exp
  ): clothing_aggregate!

  """fetch data from the table: "clothing" using primary key columns"""
  clothing_by_pk(id: Int!): clothing

  """
  fetch data from the table: "clothing_status"
  """
  clothing_status(
    """distinct select on columns"""
    distinct_on: [clothing_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_status_order_by!]

    """filter the rows returned"""
    where: clothing_status_bool_exp
  ): [clothing_status!]!

  """
  fetch aggregated fields from the table: "clothing_status"
  """
  clothing_status_aggregate(
    """distinct select on columns"""
    distinct_on: [clothing_status_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [clothing_status_order_by!]

    """filter the rows returned"""
    where: clothing_status_bool_exp
  ): clothing_status_aggregate!

  """fetch data from the table: "storage.files" using primary key columns"""
  file(id: uuid!): files

  """
  fetch data from the table: "storage.files"
  """
  files(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): [files!]!

  """
  fetch aggregated fields from the table: "storage.files"
  """
  filesAggregate(
    """distinct select on columns"""
    distinct_on: [files_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [files_order_by!]

    """filter the rows returned"""
    where: files_bool_exp
  ): files_aggregate!

  """
  fetch data from the table: "group"
  """
  group(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): [group!]!

  """
  fetch aggregated fields from the table: "group"
  """
  group_aggregate(
    """distinct select on columns"""
    distinct_on: [group_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_order_by!]

    """filter the rows returned"""
    where: group_bool_exp
  ): group_aggregate!

  """fetch data from the table: "group" using primary key columns"""
  group_by_pk(id: Int!): group

  """
  fetch data from the table: "group_member"
  """
  group_member(
    """distinct select on columns"""
    distinct_on: [group_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_member_order_by!]

    """filter the rows returned"""
    where: group_member_bool_exp
  ): [group_member!]!

  """
  fetch aggregated fields from the table: "group_member"
  """
  group_member_aggregate(
    """distinct select on columns"""
    distinct_on: [group_member_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [group_member_order_by!]

    """filter the rows returned"""
    where: group_member_bool_exp
  ): group_member_aggregate!

  """
  fetch data from the table: "rating"
  """
  rating(
    """distinct select on columns"""
    distinct_on: [rating_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rating_order_by!]

    """filter the rows returned"""
    where: rating_bool_exp
  ): [rating!]!

  """
  fetch aggregated fields from the table: "rating"
  """
  rating_aggregate(
    """distinct select on columns"""
    distinct_on: [rating_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [rating_order_by!]

    """filter the rows returned"""
    where: rating_bool_exp
  ): rating_aggregate!

  """fetch data from the table: "auth.users" using primary key columns"""
  user(id: uuid!): users

  """
  fetch aggregated fields from the table: "auth.users"
  """
  userAggregate(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): users_aggregate!

  """
  fetch data from the table: "user_avatar"
  """
  user_avatar(
    """distinct select on columns"""
    distinct_on: [user_avatar_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_avatar_order_by!]

    """filter the rows returned"""
    where: user_avatar_bool_exp
  ): [user_avatar!]!

  """
  fetch aggregated fields from the table: "user_avatar"
  """
  user_avatar_aggregate(
    """distinct select on columns"""
    distinct_on: [user_avatar_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_avatar_order_by!]

    """filter the rows returned"""
    where: user_avatar_bool_exp
  ): user_avatar_aggregate!

  """
  fetch data from the table: "user_following"
  """
  user_following(
    """distinct select on columns"""
    distinct_on: [user_following_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_following_order_by!]

    """filter the rows returned"""
    where: user_following_bool_exp
  ): [user_following!]!

  """
  fetch aggregated fields from the table: "user_following"
  """
  user_following_aggregate(
    """distinct select on columns"""
    distinct_on: [user_following_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_following_order_by!]

    """filter the rows returned"""
    where: user_following_bool_exp
  ): user_following_aggregate!

  """
  fetch data from the table: "user_wardrobe"
  """
  user_wardrobe(
    """distinct select on columns"""
    distinct_on: [user_wardrobe_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wardrobe_order_by!]

    """filter the rows returned"""
    where: user_wardrobe_bool_exp
  ): [user_wardrobe!]!

  """
  fetch aggregated fields from the table: "user_wardrobe"
  """
  user_wardrobe_aggregate(
    """distinct select on columns"""
    distinct_on: [user_wardrobe_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wardrobe_order_by!]

    """filter the rows returned"""
    where: user_wardrobe_bool_exp
  ): user_wardrobe_aggregate!

  """
  fetch data from the table: "user_wishlist"
  """
  user_wishlist(
    """distinct select on columns"""
    distinct_on: [user_wishlist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wishlist_order_by!]

    """filter the rows returned"""
    where: user_wishlist_bool_exp
  ): [user_wishlist!]!

  """
  fetch aggregated fields from the table: "user_wishlist"
  """
  user_wishlist_aggregate(
    """distinct select on columns"""
    distinct_on: [user_wishlist_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [user_wishlist_order_by!]

    """filter the rows returned"""
    where: user_wishlist_bool_exp
  ): user_wishlist_aggregate!

  """
  fetch data from the table: "auth.users"
  """
  users(
    """distinct select on columns"""
    distinct_on: [users_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [users_order_by!]

    """filter the rows returned"""
    where: users_bool_exp
  ): [users!]!
}

scalar timestamp

"""
Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'.
"""
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

scalar timestamptz

"""
Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'.
"""
input timestamptz_comparison_exp {
  _eq: timestamptz
  _gt: timestamptz
  _gte: timestamptz
  _in: [timestamptz!]
  _is_null: Boolean
  _lt: timestamptz
  _lte: timestamptz
  _neq: timestamptz
  _nin: [timestamptz!]
}

"""
columns and relationships of "user_avatar"
"""
type user_avatar {
  accessory(
    """JSON select path"""
    path: String
  ): jsonb

  """An object relationship"""
  app_user: app_user
  eyeColor(
    """JSON select path"""
    path: String
  ): jsonb
  hairStyle(
    """JSON select path"""
    path: String
  ): jsonb
  skinColor(
    """JSON select path"""
    path: String
  ): jsonb
  userId: String
}

"""
aggregated selection of "user_avatar"
"""
type user_avatar_aggregate {
  aggregate: user_avatar_aggregate_fields
  nodes: [user_avatar!]!
}

"""
aggregate fields of "user_avatar"
"""
type user_avatar_aggregate_fields {
  count(columns: [user_avatar_select_column!], distinct: Boolean): Int!
  max: user_avatar_max_fields
  min: user_avatar_min_fields
}

"""
order by aggregate values of table "user_avatar"
"""
input user_avatar_aggregate_order_by {
  count: order_by
  max: user_avatar_max_order_by
  min: user_avatar_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input user_avatar_append_input {
  accessory: jsonb
  eyeColor: jsonb
  hairStyle: jsonb
  skinColor: jsonb
}

"""
input type for inserting array relation for remote table "user_avatar"
"""
input user_avatar_arr_rel_insert_input {
  data: [user_avatar_insert_input!]!
}

"""
Boolean expression to filter rows from the table "user_avatar". All fields are combined with a logical 'AND'.
"""
input user_avatar_bool_exp {
  _and: [user_avatar_bool_exp!]
  _not: user_avatar_bool_exp
  _or: [user_avatar_bool_exp!]
  accessory: jsonb_comparison_exp
  app_user: app_user_bool_exp
  eyeColor: jsonb_comparison_exp
  hairStyle: jsonb_comparison_exp
  skinColor: jsonb_comparison_exp
  userId: String_comparison_exp
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input user_avatar_delete_at_path_input {
  accessory: [String!]
  eyeColor: [String!]
  hairStyle: [String!]
  skinColor: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input user_avatar_delete_elem_input {
  accessory: Int
  eyeColor: Int
  hairStyle: Int
  skinColor: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input user_avatar_delete_key_input {
  accessory: String
  eyeColor: String
  hairStyle: String
  skinColor: String
}

"""
input type for inserting data into table "user_avatar"
"""
input user_avatar_insert_input {
  accessory: jsonb
  app_user: app_user_obj_rel_insert_input
  eyeColor: jsonb
  hairStyle: jsonb
  skinColor: jsonb
  userId: String
}

"""aggregate max on columns"""
type user_avatar_max_fields {
  userId: String
}

"""
order by max() on columns of table "user_avatar"
"""
input user_avatar_max_order_by {
  userId: order_by
}

"""aggregate min on columns"""
type user_avatar_min_fields {
  userId: String
}

"""
order by min() on columns of table "user_avatar"
"""
input user_avatar_min_order_by {
  userId: order_by
}

"""
response of any mutation on the table "user_avatar"
"""
type user_avatar_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_avatar!]!
}

"""Ordering options when selecting data from "user_avatar"."""
input user_avatar_order_by {
  accessory: order_by
  app_user: app_user_order_by
  eyeColor: order_by
  hairStyle: order_by
  skinColor: order_by
  userId: order_by
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input user_avatar_prepend_input {
  accessory: jsonb
  eyeColor: jsonb
  hairStyle: jsonb
  skinColor: jsonb
}

"""
select columns of table "user_avatar"
"""
enum user_avatar_select_column {
  """column name"""
  accessory

  """column name"""
  eyeColor

  """column name"""
  hairStyle

  """column name"""
  skinColor

  """column name"""
  userId
}

"""
input type for updating data in table "user_avatar"
"""
input user_avatar_set_input {
  accessory: jsonb
  eyeColor: jsonb
  hairStyle: jsonb
  skinColor: jsonb
  userId: String
}

"""
columns and relationships of "user_following"
"""
type user_following {
  """An object relationship"""
  appUserByUserid: app_user

  """An object relationship"""
  app_user: app_user
  followedUserId: String
  userId: String
}

"""
aggregated selection of "user_following"
"""
type user_following_aggregate {
  aggregate: user_following_aggregate_fields
  nodes: [user_following!]!
}

"""
aggregate fields of "user_following"
"""
type user_following_aggregate_fields {
  count(columns: [user_following_select_column!], distinct: Boolean): Int!
  max: user_following_max_fields
  min: user_following_min_fields
}

"""
order by aggregate values of table "user_following"
"""
input user_following_aggregate_order_by {
  count: order_by
  max: user_following_max_order_by
  min: user_following_min_order_by
}

"""
input type for inserting array relation for remote table "user_following"
"""
input user_following_arr_rel_insert_input {
  data: [user_following_insert_input!]!
}

"""
Boolean expression to filter rows from the table "user_following". All fields are combined with a logical 'AND'.
"""
input user_following_bool_exp {
  _and: [user_following_bool_exp!]
  _not: user_following_bool_exp
  _or: [user_following_bool_exp!]
  appUserByUserid: app_user_bool_exp
  app_user: app_user_bool_exp
  followedUserId: String_comparison_exp
  userId: String_comparison_exp
}

"""
input type for inserting data into table "user_following"
"""
input user_following_insert_input {
  appUserByUserid: app_user_obj_rel_insert_input
  app_user: app_user_obj_rel_insert_input
  followedUserId: String
  userId: String
}

"""aggregate max on columns"""
type user_following_max_fields {
  followedUserId: String
  userId: String
}

"""
order by max() on columns of table "user_following"
"""
input user_following_max_order_by {
  followedUserId: order_by
  userId: order_by
}

"""aggregate min on columns"""
type user_following_min_fields {
  followedUserId: String
  userId: String
}

"""
order by min() on columns of table "user_following"
"""
input user_following_min_order_by {
  followedUserId: order_by
  userId: order_by
}

"""
response of any mutation on the table "user_following"
"""
type user_following_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_following!]!
}

"""Ordering options when selecting data from "user_following"."""
input user_following_order_by {
  appUserByUserid: app_user_order_by
  app_user: app_user_order_by
  followedUserId: order_by
  userId: order_by
}

"""
select columns of table "user_following"
"""
enum user_following_select_column {
  """column name"""
  followedUserId

  """column name"""
  userId
}

"""
input type for updating data in table "user_following"
"""
input user_following_set_input {
  followedUserId: String
  userId: String
}

"""
columns and relationships of "user_wardrobe"
"""
type user_wardrobe {
  """An object relationship"""
  app_user: app_user

  """An object relationship"""
  clothing: clothing
  clothingId: Int
  userId: String
}

"""
aggregated selection of "user_wardrobe"
"""
type user_wardrobe_aggregate {
  aggregate: user_wardrobe_aggregate_fields
  nodes: [user_wardrobe!]!
}

"""
aggregate fields of "user_wardrobe"
"""
type user_wardrobe_aggregate_fields {
  avg: user_wardrobe_avg_fields
  count(columns: [user_wardrobe_select_column!], distinct: Boolean): Int!
  max: user_wardrobe_max_fields
  min: user_wardrobe_min_fields
  stddev: user_wardrobe_stddev_fields
  stddev_pop: user_wardrobe_stddev_pop_fields
  stddev_samp: user_wardrobe_stddev_samp_fields
  sum: user_wardrobe_sum_fields
  var_pop: user_wardrobe_var_pop_fields
  var_samp: user_wardrobe_var_samp_fields
  variance: user_wardrobe_variance_fields
}

"""
order by aggregate values of table "user_wardrobe"
"""
input user_wardrobe_aggregate_order_by {
  avg: user_wardrobe_avg_order_by
  count: order_by
  max: user_wardrobe_max_order_by
  min: user_wardrobe_min_order_by
  stddev: user_wardrobe_stddev_order_by
  stddev_pop: user_wardrobe_stddev_pop_order_by
  stddev_samp: user_wardrobe_stddev_samp_order_by
  sum: user_wardrobe_sum_order_by
  var_pop: user_wardrobe_var_pop_order_by
  var_samp: user_wardrobe_var_samp_order_by
  variance: user_wardrobe_variance_order_by
}

"""
input type for inserting array relation for remote table "user_wardrobe"
"""
input user_wardrobe_arr_rel_insert_input {
  data: [user_wardrobe_insert_input!]!
}

"""aggregate avg on columns"""
type user_wardrobe_avg_fields {
  clothingId: Float
}

"""
order by avg() on columns of table "user_wardrobe"
"""
input user_wardrobe_avg_order_by {
  clothingId: order_by
}

"""
Boolean expression to filter rows from the table "user_wardrobe". All fields are combined with a logical 'AND'.
"""
input user_wardrobe_bool_exp {
  _and: [user_wardrobe_bool_exp!]
  _not: user_wardrobe_bool_exp
  _or: [user_wardrobe_bool_exp!]
  app_user: app_user_bool_exp
  clothing: clothing_bool_exp
  clothingId: Int_comparison_exp
  userId: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "user_wardrobe"
"""
input user_wardrobe_inc_input {
  clothingId: Int
}

"""
input type for inserting data into table "user_wardrobe"
"""
input user_wardrobe_insert_input {
  app_user: app_user_obj_rel_insert_input
  clothing: clothing_obj_rel_insert_input
  clothingId: Int
  userId: String
}

"""aggregate max on columns"""
type user_wardrobe_max_fields {
  clothingId: Int
  userId: String
}

"""
order by max() on columns of table "user_wardrobe"
"""
input user_wardrobe_max_order_by {
  clothingId: order_by
  userId: order_by
}

"""aggregate min on columns"""
type user_wardrobe_min_fields {
  clothingId: Int
  userId: String
}

"""
order by min() on columns of table "user_wardrobe"
"""
input user_wardrobe_min_order_by {
  clothingId: order_by
  userId: order_by
}

"""
response of any mutation on the table "user_wardrobe"
"""
type user_wardrobe_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_wardrobe!]!
}

"""Ordering options when selecting data from "user_wardrobe"."""
input user_wardrobe_order_by {
  app_user: app_user_order_by
  clothing: clothing_order_by
  clothingId: order_by
  userId: order_by
}

"""
select columns of table "user_wardrobe"
"""
enum user_wardrobe_select_column {
  """column name"""
  clothingId

  """column name"""
  userId
}

"""
input type for updating data in table "user_wardrobe"
"""
input user_wardrobe_set_input {
  clothingId: Int
  userId: String
}

"""aggregate stddev on columns"""
type user_wardrobe_stddev_fields {
  clothingId: Float
}

"""
order by stddev() on columns of table "user_wardrobe"
"""
input user_wardrobe_stddev_order_by {
  clothingId: order_by
}

"""aggregate stddev_pop on columns"""
type user_wardrobe_stddev_pop_fields {
  clothingId: Float
}

"""
order by stddev_pop() on columns of table "user_wardrobe"
"""
input user_wardrobe_stddev_pop_order_by {
  clothingId: order_by
}

"""aggregate stddev_samp on columns"""
type user_wardrobe_stddev_samp_fields {
  clothingId: Float
}

"""
order by stddev_samp() on columns of table "user_wardrobe"
"""
input user_wardrobe_stddev_samp_order_by {
  clothingId: order_by
}

"""aggregate sum on columns"""
type user_wardrobe_sum_fields {
  clothingId: Int
}

"""
order by sum() on columns of table "user_wardrobe"
"""
input user_wardrobe_sum_order_by {
  clothingId: order_by
}

"""aggregate var_pop on columns"""
type user_wardrobe_var_pop_fields {
  clothingId: Float
}

"""
order by var_pop() on columns of table "user_wardrobe"
"""
input user_wardrobe_var_pop_order_by {
  clothingId: order_by
}

"""aggregate var_samp on columns"""
type user_wardrobe_var_samp_fields {
  clothingId: Float
}

"""
order by var_samp() on columns of table "user_wardrobe"
"""
input user_wardrobe_var_samp_order_by {
  clothingId: order_by
}

"""aggregate variance on columns"""
type user_wardrobe_variance_fields {
  clothingId: Float
}

"""
order by variance() on columns of table "user_wardrobe"
"""
input user_wardrobe_variance_order_by {
  clothingId: order_by
}

"""
columns and relationships of "user_wishlist"
"""
type user_wishlist {
  """An object relationship"""
  app_user: app_user

  """An object relationship"""
  clothing: clothing
  clothingId: Int
  createdAt: timestamp
  userId: String
}

"""
aggregated selection of "user_wishlist"
"""
type user_wishlist_aggregate {
  aggregate: user_wishlist_aggregate_fields
  nodes: [user_wishlist!]!
}

"""
aggregate fields of "user_wishlist"
"""
type user_wishlist_aggregate_fields {
  avg: user_wishlist_avg_fields
  count(columns: [user_wishlist_select_column!], distinct: Boolean): Int!
  max: user_wishlist_max_fields
  min: user_wishlist_min_fields
  stddev: user_wishlist_stddev_fields
  stddev_pop: user_wishlist_stddev_pop_fields
  stddev_samp: user_wishlist_stddev_samp_fields
  sum: user_wishlist_sum_fields
  var_pop: user_wishlist_var_pop_fields
  var_samp: user_wishlist_var_samp_fields
  variance: user_wishlist_variance_fields
}

"""
order by aggregate values of table "user_wishlist"
"""
input user_wishlist_aggregate_order_by {
  avg: user_wishlist_avg_order_by
  count: order_by
  max: user_wishlist_max_order_by
  min: user_wishlist_min_order_by
  stddev: user_wishlist_stddev_order_by
  stddev_pop: user_wishlist_stddev_pop_order_by
  stddev_samp: user_wishlist_stddev_samp_order_by
  sum: user_wishlist_sum_order_by
  var_pop: user_wishlist_var_pop_order_by
  var_samp: user_wishlist_var_samp_order_by
  variance: user_wishlist_variance_order_by
}

"""
input type for inserting array relation for remote table "user_wishlist"
"""
input user_wishlist_arr_rel_insert_input {
  data: [user_wishlist_insert_input!]!
}

"""aggregate avg on columns"""
type user_wishlist_avg_fields {
  clothingId: Float
}

"""
order by avg() on columns of table "user_wishlist"
"""
input user_wishlist_avg_order_by {
  clothingId: order_by
}

"""
Boolean expression to filter rows from the table "user_wishlist". All fields are combined with a logical 'AND'.
"""
input user_wishlist_bool_exp {
  _and: [user_wishlist_bool_exp!]
  _not: user_wishlist_bool_exp
  _or: [user_wishlist_bool_exp!]
  app_user: app_user_bool_exp
  clothing: clothing_bool_exp
  clothingId: Int_comparison_exp
  createdAt: timestamp_comparison_exp
  userId: String_comparison_exp
}

"""
input type for incrementing numeric columns in table "user_wishlist"
"""
input user_wishlist_inc_input {
  clothingId: Int
}

"""
input type for inserting data into table "user_wishlist"
"""
input user_wishlist_insert_input {
  app_user: app_user_obj_rel_insert_input
  clothing: clothing_obj_rel_insert_input
  clothingId: Int
  createdAt: timestamp
  userId: String
}

"""aggregate max on columns"""
type user_wishlist_max_fields {
  clothingId: Int
  createdAt: timestamp
  userId: String
}

"""
order by max() on columns of table "user_wishlist"
"""
input user_wishlist_max_order_by {
  clothingId: order_by
  createdAt: order_by
  userId: order_by
}

"""aggregate min on columns"""
type user_wishlist_min_fields {
  clothingId: Int
  createdAt: timestamp
  userId: String
}

"""
order by min() on columns of table "user_wishlist"
"""
input user_wishlist_min_order_by {
  clothingId: order_by
  createdAt: order_by
  userId: order_by
}

"""
response of any mutation on the table "user_wishlist"
"""
type user_wishlist_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [user_wishlist!]!
}

"""Ordering options when selecting data from "user_wishlist"."""
input user_wishlist_order_by {
  app_user: app_user_order_by
  clothing: clothing_order_by
  clothingId: order_by
  createdAt: order_by
  userId: order_by
}

"""
select columns of table "user_wishlist"
"""
enum user_wishlist_select_column {
  """column name"""
  clothingId

  """column name"""
  createdAt

  """column name"""
  userId
}

"""
input type for updating data in table "user_wishlist"
"""
input user_wishlist_set_input {
  clothingId: Int
  createdAt: timestamp
  userId: String
}

"""aggregate stddev on columns"""
type user_wishlist_stddev_fields {
  clothingId: Float
}

"""
order by stddev() on columns of table "user_wishlist"
"""
input user_wishlist_stddev_order_by {
  clothingId: order_by
}

"""aggregate stddev_pop on columns"""
type user_wishlist_stddev_pop_fields {
  clothingId: Float
}

"""
order by stddev_pop() on columns of table "user_wishlist"
"""
input user_wishlist_stddev_pop_order_by {
  clothingId: order_by
}

"""aggregate stddev_samp on columns"""
type user_wishlist_stddev_samp_fields {
  clothingId: Float
}

"""
order by stddev_samp() on columns of table "user_wishlist"
"""
input user_wishlist_stddev_samp_order_by {
  clothingId: order_by
}

"""aggregate sum on columns"""
type user_wishlist_sum_fields {
  clothingId: Int
}

"""
order by sum() on columns of table "user_wishlist"
"""
input user_wishlist_sum_order_by {
  clothingId: order_by
}

"""aggregate var_pop on columns"""
type user_wishlist_var_pop_fields {
  clothingId: Float
}

"""
order by var_pop() on columns of table "user_wishlist"
"""
input user_wishlist_var_pop_order_by {
  clothingId: order_by
}

"""aggregate var_samp on columns"""
type user_wishlist_var_samp_fields {
  clothingId: Float
}

"""
order by var_samp() on columns of table "user_wishlist"
"""
input user_wishlist_var_samp_order_by {
  clothingId: order_by
}

"""aggregate variance on columns"""
type user_wishlist_variance_fields {
  clothingId: Float
}

"""
order by variance() on columns of table "user_wishlist"
"""
input user_wishlist_variance_order_by {
  clothingId: order_by
}

"""
columns and relationships of "auth.users"
"""
type users {
  activeMfaType: String
  avatarUrl: String!
  createdAt: timestamptz!
  defaultRole: String!

  """An object relationship"""
  defaultRoleByRole: authRoles!
  disabled: Boolean!
  displayName: String!
  email: citext
  emailVerified: Boolean!
  id: uuid!
  isAnonymous: Boolean!
  lastSeen: timestamptz
  locale: String!
  metadata(
    """JSON select path"""
    path: String
  ): jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz!
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean!

  """An array relationship"""
  refreshTokens(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): [authRefreshTokens!]!

  """An aggregate relationship"""
  refreshTokens_aggregate(
    """distinct select on columns"""
    distinct_on: [authRefreshTokens_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authRefreshTokens_order_by!]

    """filter the rows returned"""
    where: authRefreshTokens_bool_exp
  ): authRefreshTokens_aggregate!

  """An array relationship"""
  roles(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): [authUserRoles!]!

  """An aggregate relationship"""
  roles_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserRoles_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserRoles_order_by!]

    """filter the rows returned"""
    where: authUserRoles_bool_exp
  ): authUserRoles_aggregate!
  ticket: String
  ticketExpiresAt: timestamptz!
  totpSecret: String
  updatedAt: timestamptz!

  """An array relationship"""
  userProviders(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): [authUserProviders!]!

  """An aggregate relationship"""
  userProviders_aggregate(
    """distinct select on columns"""
    distinct_on: [authUserProviders_select_column!]

    """limit the number of rows returned"""
    limit: Int

    """skip the first n rows. Use only with order_by"""
    offset: Int

    """sort the rows by one or more columns"""
    order_by: [authUserProviders_order_by!]

    """filter the rows returned"""
    where: authUserProviders_bool_exp
  ): authUserProviders_aggregate!
}

"""
aggregated selection of "auth.users"
"""
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

"""
aggregate fields of "auth.users"
"""
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int!
  max: users_max_fields
  min: users_min_fields
}

"""
order by aggregate values of table "auth.users"
"""
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

"""append existing jsonb value of filtered columns with new jsonb value"""
input users_append_input {
  metadata: jsonb
}

"""
input type for inserting array relation for remote table "auth.users"
"""
input users_arr_rel_insert_input {
  data: [users_insert_input!]!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
Boolean expression to filter rows from the table "auth.users". All fields are combined with a logical 'AND'.
"""
input users_bool_exp {
  _and: [users_bool_exp!]
  _not: users_bool_exp
  _or: [users_bool_exp!]
  activeMfaType: String_comparison_exp
  avatarUrl: String_comparison_exp
  createdAt: timestamptz_comparison_exp
  defaultRole: String_comparison_exp
  defaultRoleByRole: authRoles_bool_exp
  disabled: Boolean_comparison_exp
  displayName: String_comparison_exp
  email: citext_comparison_exp
  emailVerified: Boolean_comparison_exp
  id: uuid_comparison_exp
  isAnonymous: Boolean_comparison_exp
  lastSeen: timestamptz_comparison_exp
  locale: String_comparison_exp
  metadata: jsonb_comparison_exp
  newEmail: citext_comparison_exp
  otpHash: String_comparison_exp
  otpHashExpiresAt: timestamptz_comparison_exp
  otpMethodLastUsed: String_comparison_exp
  passwordHash: String_comparison_exp
  phoneNumber: String_comparison_exp
  phoneNumberVerified: Boolean_comparison_exp
  refreshTokens: authRefreshTokens_bool_exp
  roles: authUserRoles_bool_exp
  ticket: String_comparison_exp
  ticketExpiresAt: timestamptz_comparison_exp
  totpSecret: String_comparison_exp
  updatedAt: timestamptz_comparison_exp
  userProviders: authUserProviders_bool_exp
}

"""
unique or primary key constraints on table "auth.users"
"""
enum users_constraint {
  """unique or primary key constraint"""
  users_email_key

  """unique or primary key constraint"""
  users_phone_number_key

  """unique or primary key constraint"""
  users_pkey
}

"""
delete the field or element with specified path (for JSON arrays, negative integers count from the end)
"""
input users_delete_at_path_input {
  metadata: [String!]
}

"""
delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array
"""
input users_delete_elem_input {
  metadata: Int
}

"""
delete key/value pair or string element. key/value pairs are matched based on their key value
"""
input users_delete_key_input {
  metadata: String
}

"""
input type for inserting data into table "auth.users"
"""
input users_insert_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  defaultRole: String
  defaultRoleByRole: authRoles_obj_rel_insert_input
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  refreshTokens: authRefreshTokens_arr_rel_insert_input
  roles: authUserRoles_arr_rel_insert_input
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
  userProviders: authUserProviders_arr_rel_insert_input
}

"""aggregate max on columns"""
type users_max_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by max() on columns of table "auth.users"
"""
input users_max_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""aggregate min on columns"""
type users_min_fields {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  defaultRole: String
  displayName: String
  email: citext
  id: uuid
  lastSeen: timestamptz
  locale: String
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
order by min() on columns of table "auth.users"
"""
input users_min_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  defaultRole: order_by
  displayName: order_by
  email: order_by
  id: order_by
  lastSeen: order_by
  locale: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
}

"""
response of any mutation on the table "auth.users"
"""
type users_mutation_response {
  """number of rows affected by the mutation"""
  affected_rows: Int!

  """data from the rows affected by the mutation"""
  returning: [users!]!
}

"""
input type for inserting object relation for remote table "auth.users"
"""
input users_obj_rel_insert_input {
  data: users_insert_input!

  """upsert condition"""
  on_conflict: users_on_conflict
}

"""
on_conflict condition type for table "auth.users"
"""
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]! = []
  where: users_bool_exp
}

"""Ordering options when selecting data from "auth.users"."""
input users_order_by {
  activeMfaType: order_by
  avatarUrl: order_by
  createdAt: order_by
  defaultRole: order_by
  defaultRoleByRole: authRoles_order_by
  disabled: order_by
  displayName: order_by
  email: order_by
  emailVerified: order_by
  id: order_by
  isAnonymous: order_by
  lastSeen: order_by
  locale: order_by
  metadata: order_by
  newEmail: order_by
  otpHash: order_by
  otpHashExpiresAt: order_by
  otpMethodLastUsed: order_by
  passwordHash: order_by
  phoneNumber: order_by
  phoneNumberVerified: order_by
  refreshTokens_aggregate: authRefreshTokens_aggregate_order_by
  roles_aggregate: authUserRoles_aggregate_order_by
  ticket: order_by
  ticketExpiresAt: order_by
  totpSecret: order_by
  updatedAt: order_by
  userProviders_aggregate: authUserProviders_aggregate_order_by
}

"""primary key columns input for table: users"""
input users_pk_columns_input {
  id: uuid!
}

"""prepend existing jsonb value of filtered columns with new jsonb value"""
input users_prepend_input {
  metadata: jsonb
}

"""
select columns of table "auth.users"
"""
enum users_select_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

"""
input type for updating data in table "auth.users"
"""
input users_set_input {
  activeMfaType: String
  avatarUrl: String
  createdAt: timestamptz
  defaultRole: String
  disabled: Boolean
  displayName: String
  email: citext
  emailVerified: Boolean
  id: uuid
  isAnonymous: Boolean
  lastSeen: timestamptz
  locale: String
  metadata: jsonb
  newEmail: citext
  otpHash: String
  otpHashExpiresAt: timestamptz
  otpMethodLastUsed: String
  passwordHash: String
  phoneNumber: String
  phoneNumberVerified: Boolean
  ticket: String
  ticketExpiresAt: timestamptz
  totpSecret: String
  updatedAt: timestamptz
}

"""
update columns of table "auth.users"
"""
enum users_update_column {
  """column name"""
  activeMfaType

  """column name"""
  avatarUrl

  """column name"""
  createdAt

  """column name"""
  defaultRole

  """column name"""
  disabled

  """column name"""
  displayName

  """column name"""
  email

  """column name"""
  emailVerified

  """column name"""
  id

  """column name"""
  isAnonymous

  """column name"""
  lastSeen

  """column name"""
  locale

  """column name"""
  metadata

  """column name"""
  newEmail

  """column name"""
  otpHash

  """column name"""
  otpHashExpiresAt

  """column name"""
  otpMethodLastUsed

  """column name"""
  passwordHash

  """column name"""
  phoneNumber

  """column name"""
  phoneNumberVerified

  """column name"""
  ticket

  """column name"""
  ticketExpiresAt

  """column name"""
  totpSecret

  """column name"""
  updatedAt
}

scalar uuid

"""
Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'.
"""
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

